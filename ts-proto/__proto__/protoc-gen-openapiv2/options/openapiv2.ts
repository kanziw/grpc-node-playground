// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.178.0
//   protoc               unknown
// source: protoc-gen-openapiv2/options/openapiv2.proto

/* eslint-disable */
import Long from "long";
import _m0 from "protobufjs/minimal.js";
import { Value } from "../../google/protobuf/struct.js";

export const protobufPackage = "grpc.gateway.protoc_gen_openapiv2.options";

/**
 * Scheme describes the schemes supported by the OpenAPI Swagger
 * and Operation objects.
 */
export const Scheme = { UNKNOWN: "UNKNOWN", HTTP: "HTTP", HTTPS: "HTTPS", WS: "WS", WSS: "WSS" } as const;

export type Scheme = typeof Scheme[keyof typeof Scheme];

export namespace Scheme {
  export type UNKNOWN = typeof Scheme.UNKNOWN;
  export type HTTP = typeof Scheme.HTTP;
  export type HTTPS = typeof Scheme.HTTPS;
  export type WS = typeof Scheme.WS;
  export type WSS = typeof Scheme.WSS;
}

export function schemeFromJSON(object: any): Scheme {
  switch (object) {
    case 0:
    case "UNKNOWN":
      return Scheme.UNKNOWN;
    case 1:
    case "HTTP":
      return Scheme.HTTP;
    case 2:
    case "HTTPS":
      return Scheme.HTTPS;
    case 3:
    case "WS":
      return Scheme.WS;
    case 4:
    case "WSS":
      return Scheme.WSS;
    default:
      return Scheme.UNKNOWN;
  }
}

export function schemeToJSON(object: Scheme): string {
  switch (object) {
    case Scheme.UNKNOWN:
      return "UNKNOWN";
    case Scheme.HTTP:
      return "HTTP";
    case Scheme.HTTPS:
      return "HTTPS";
    case Scheme.WS:
      return "WS";
    case Scheme.WSS:
      return "WSS";
    default:
      return "UNKNOWN";
  }
}

export function schemeToNumber(object: Scheme): number {
  switch (object) {
    case Scheme.UNKNOWN:
      return 0;
    case Scheme.HTTP:
      return 1;
    case Scheme.HTTPS:
      return 2;
    case Scheme.WS:
      return 3;
    case Scheme.WSS:
      return 4;
    default:
      return 0;
  }
}

/**
 * `Swagger` is a representation of OpenAPI v2 specification's Swagger object.
 *
 * See: https://github.com/OAI/OpenAPI-Specification/blob/3.0.0/versions/2.0.md#swaggerObject
 *
 * Example:
 *
 *  option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_swagger) = {
 *    info: {
 *      title: "Echo API";
 *      version: "1.0";
 *      description: "";
 *      contact: {
 *        name: "gRPC-Gateway project";
 *        url: "https://github.com/grpc-ecosystem/grpc-gateway";
 *        email: "none@example.com";
 *      };
 *      license: {
 *        name: "BSD 3-Clause License";
 *        url: "https://github.com/grpc-ecosystem/grpc-gateway/blob/main/LICENSE";
 *      };
 *    };
 *    schemes: HTTPS;
 *    consumes: "application/json";
 *    produces: "application/json";
 *  };
 */
export interface Swagger {
  /**
   * Specifies the OpenAPI Specification version being used. It can be
   * used by the OpenAPI UI and other clients to interpret the API listing. The
   * value MUST be "2.0".
   */
  swagger: string;
  /**
   * Provides metadata about the API. The metadata can be used by the
   * clients if needed.
   */
  info?:
    | Info
    | null;
  /**
   * The host (name or ip) serving the API. This MUST be the host only and does
   * not include the scheme nor sub-paths. It MAY include a port. If the host is
   * not included, the host serving the documentation is to be used (including
   * the port). The host does not support path templating.
   */
  host: string;
  /**
   * The base path on which the API is served, which is relative to the host. If
   * it is not included, the API is served directly under the host. The value
   * MUST start with a leading slash (/). The basePath does not support path
   * templating.
   * Note that using `base_path` does not change the endpoint paths that are
   * generated in the resulting OpenAPI file. If you wish to use `base_path`
   * with relatively generated OpenAPI paths, the `base_path` prefix must be
   * manually removed from your `google.api.http` paths and your code changed to
   * serve the API from the `base_path`.
   */
  base_path: string;
  /**
   * The transfer protocol of the API. Values MUST be from the list: "http",
   * "https", "ws", "wss". If the schemes is not included, the default scheme to
   * be used is the one used to access the OpenAPI definition itself.
   */
  schemes: Scheme[];
  /**
   * A list of MIME types the APIs can consume. This is global to all APIs but
   * can be overridden on specific API calls. Value MUST be as described under
   * Mime Types.
   */
  consumes: string[];
  /**
   * A list of MIME types the APIs can produce. This is global to all APIs but
   * can be overridden on specific API calls. Value MUST be as described under
   * Mime Types.
   */
  produces: string[];
  /**
   * An object to hold responses that can be used across operations. This
   * property does not define global responses for all operations.
   */
  responses: { [key: string]: Response };
  /** Security scheme definitions that can be used across the specification. */
  security_definitions?:
    | SecurityDefinitions
    | null;
  /**
   * A declaration of which security schemes are applied for the API as a whole.
   * The list of values describes alternative security schemes that can be used
   * (that is, there is a logical OR between the security requirements).
   * Individual operations can override this definition.
   */
  security: SecurityRequirement[];
  /**
   * A list of tags for API documentation control. Tags can be used for logical
   * grouping of operations by resources or any other qualifier.
   */
  tags: Tag[];
  /** Additional external documentation. */
  external_docs?:
    | ExternalDocumentation
    | null;
  /**
   * Custom properties that start with "x-" such as "x-foo" used to describe
   * extra functionality that is not covered by the standard OpenAPI Specification.
   * See: https://swagger.io/docs/specification/2-0/swagger-extensions/
   */
  extensions: { [key: string]: any | null };
}

export interface Swagger_ResponsesEntry {
  key: string;
  value?: Response | null;
}

export interface Swagger_ExtensionsEntry {
  key: string;
  value?: any | null;
}

/**
 * `Operation` is a representation of OpenAPI v2 specification's Operation object.
 *
 * See: https://github.com/OAI/OpenAPI-Specification/blob/3.0.0/versions/2.0.md#operationObject
 *
 * Example:
 *
 *  service EchoService {
 *    rpc Echo(SimpleMessage) returns (SimpleMessage) {
 *      option (google.api.http) = {
 *        get: "/v1/example/echo/{id}"
 *      };
 *
 *      option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
 *        summary: "Get a message.";
 *        operation_id: "getMessage";
 *        tags: "echo";
 *        responses: {
 *          key: "200"
 *            value: {
 *            description: "OK";
 *          }
 *        }
 *      };
 *    }
 *  }
 */
export interface Operation {
  /**
   * A list of tags for API documentation control. Tags can be used for logical
   * grouping of operations by resources or any other qualifier.
   */
  tags: string[];
  /**
   * A short summary of what the operation does. For maximum readability in the
   * swagger-ui, this field SHOULD be less than 120 characters.
   */
  summary: string;
  /**
   * A verbose explanation of the operation behavior. GFM syntax can be used for
   * rich text representation.
   */
  description: string;
  /** Additional external documentation for this operation. */
  external_docs?:
    | ExternalDocumentation
    | null;
  /**
   * Unique string used to identify the operation. The id MUST be unique among
   * all operations described in the API. Tools and libraries MAY use the
   * operationId to uniquely identify an operation, therefore, it is recommended
   * to follow common programming naming conventions.
   */
  operation_id: string;
  /**
   * A list of MIME types the operation can consume. This overrides the consumes
   * definition at the OpenAPI Object. An empty value MAY be used to clear the
   * global definition. Value MUST be as described under Mime Types.
   */
  consumes: string[];
  /**
   * A list of MIME types the operation can produce. This overrides the produces
   * definition at the OpenAPI Object. An empty value MAY be used to clear the
   * global definition. Value MUST be as described under Mime Types.
   */
  produces: string[];
  /**
   * The list of possible responses as they are returned from executing this
   * operation.
   */
  responses: { [key: string]: Response };
  /**
   * The transfer protocol for the operation. Values MUST be from the list:
   * "http", "https", "ws", "wss". The value overrides the OpenAPI Object
   * schemes definition.
   */
  schemes: Scheme[];
  /**
   * Declares this operation to be deprecated. Usage of the declared operation
   * should be refrained. Default value is false.
   */
  deprecated: boolean;
  /**
   * A declaration of which security schemes are applied for this operation. The
   * list of values describes alternative security schemes that can be used
   * (that is, there is a logical OR between the security requirements). This
   * definition overrides any declared top-level security. To remove a top-level
   * security declaration, an empty array can be used.
   */
  security: SecurityRequirement[];
  /**
   * Custom properties that start with "x-" such as "x-foo" used to describe
   * extra functionality that is not covered by the standard OpenAPI Specification.
   * See: https://swagger.io/docs/specification/2-0/swagger-extensions/
   */
  extensions: { [key: string]: any | null };
  /**
   * Custom parameters such as HTTP request headers.
   * See: https://swagger.io/docs/specification/2-0/describing-parameters/
   * and https://swagger.io/specification/v2/#parameter-object.
   */
  parameters?: Parameters | null;
}

export interface Operation_ResponsesEntry {
  key: string;
  value?: Response | null;
}

export interface Operation_ExtensionsEntry {
  key: string;
  value?: any | null;
}

/**
 * `Parameters` is a representation of OpenAPI v2 specification's parameters object.
 * Note: This technically breaks compatibility with the OpenAPI 2 definition structure as we only
 * allow header parameters to be set here since we do not want users specifying custom non-header
 * parameters beyond those inferred from the Protobuf schema.
 * See: https://swagger.io/specification/v2/#parameter-object
 */
export interface Parameters {
  /**
   * `Headers` is one or more HTTP header parameter.
   * See: https://swagger.io/docs/specification/2-0/describing-parameters/#header-parameters
   */
  headers: HeaderParameter[];
}

/**
 * `HeaderParameter` a HTTP header parameter.
 * See: https://swagger.io/specification/v2/#parameter-object
 */
export interface HeaderParameter {
  /** `Name` is the header name. */
  name: string;
  /** `Description` is a short description of the header. */
  description: string;
  /**
   * `Type` is the type of the object. The value MUST be one of "string", "number", "integer", or "boolean". The "array" type is not supported.
   * See: https://swagger.io/specification/v2/#parameterType.
   */
  type: HeaderParameter_Type;
  /** `Format` The extending format for the previously mentioned type. */
  format: string;
  /** `Required` indicates if the header is optional */
  required: boolean;
}

/**
 * `Type` is a supported HTTP header type.
 * See https://swagger.io/specification/v2/#parameterType.
 */
export const HeaderParameter_Type = {
  UNKNOWN: "UNKNOWN",
  STRING: "STRING",
  NUMBER: "NUMBER",
  INTEGER: "INTEGER",
  BOOLEAN: "BOOLEAN",
} as const;

export type HeaderParameter_Type = typeof HeaderParameter_Type[keyof typeof HeaderParameter_Type];

export namespace HeaderParameter_Type {
  export type UNKNOWN = typeof HeaderParameter_Type.UNKNOWN;
  export type STRING = typeof HeaderParameter_Type.STRING;
  export type NUMBER = typeof HeaderParameter_Type.NUMBER;
  export type INTEGER = typeof HeaderParameter_Type.INTEGER;
  export type BOOLEAN = typeof HeaderParameter_Type.BOOLEAN;
}

export function headerParameter_TypeFromJSON(object: any): HeaderParameter_Type {
  switch (object) {
    case 0:
    case "UNKNOWN":
      return HeaderParameter_Type.UNKNOWN;
    case 1:
    case "STRING":
      return HeaderParameter_Type.STRING;
    case 2:
    case "NUMBER":
      return HeaderParameter_Type.NUMBER;
    case 3:
    case "INTEGER":
      return HeaderParameter_Type.INTEGER;
    case 4:
    case "BOOLEAN":
      return HeaderParameter_Type.BOOLEAN;
    default:
      return HeaderParameter_Type.UNKNOWN;
  }
}

export function headerParameter_TypeToJSON(object: HeaderParameter_Type): string {
  switch (object) {
    case HeaderParameter_Type.UNKNOWN:
      return "UNKNOWN";
    case HeaderParameter_Type.STRING:
      return "STRING";
    case HeaderParameter_Type.NUMBER:
      return "NUMBER";
    case HeaderParameter_Type.INTEGER:
      return "INTEGER";
    case HeaderParameter_Type.BOOLEAN:
      return "BOOLEAN";
    default:
      return "UNKNOWN";
  }
}

export function headerParameter_TypeToNumber(object: HeaderParameter_Type): number {
  switch (object) {
    case HeaderParameter_Type.UNKNOWN:
      return 0;
    case HeaderParameter_Type.STRING:
      return 1;
    case HeaderParameter_Type.NUMBER:
      return 2;
    case HeaderParameter_Type.INTEGER:
      return 3;
    case HeaderParameter_Type.BOOLEAN:
      return 4;
    default:
      return 0;
  }
}

/**
 * `Header` is a representation of OpenAPI v2 specification's Header object.
 *
 * See: https://github.com/OAI/OpenAPI-Specification/blob/3.0.0/versions/2.0.md#headerObject
 */
export interface Header {
  /** `Description` is a short description of the header. */
  description: string;
  /** The type of the object. The value MUST be one of "string", "number", "integer", or "boolean". The "array" type is not supported. */
  type: string;
  /** `Format` The extending format for the previously mentioned type. */
  format: string;
  /**
   * `Default` Declares the value of the header that the server will use if none is provided.
   * See: https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-6.2.
   * Unlike JSON Schema this value MUST conform to the defined type for the header.
   */
  default: string;
  /** 'Pattern' See https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-5.2.3. */
  pattern: string;
}

/**
 * `Response` is a representation of OpenAPI v2 specification's Response object.
 *
 * See: https://github.com/OAI/OpenAPI-Specification/blob/3.0.0/versions/2.0.md#responseObject
 */
export interface Response {
  /**
   * `Description` is a short description of the response.
   * GFM syntax can be used for rich text representation.
   */
  description: string;
  /**
   * `Schema` optionally defines the structure of the response.
   * If `Schema` is not provided, it means there is no content to the response.
   */
  schema?:
    | Schema
    | null;
  /**
   * `Headers` A list of headers that are sent with the response.
   * `Header` name is expected to be a string in the canonical format of the MIME header key
   * See: https://golang.org/pkg/net/textproto/#CanonicalMIMEHeaderKey
   */
  headers: { [key: string]: Header };
  /**
   * `Examples` gives per-mimetype response examples.
   * See: https://github.com/OAI/OpenAPI-Specification/blob/3.0.0/versions/2.0.md#example-object
   */
  examples: { [key: string]: string };
  /**
   * Custom properties that start with "x-" such as "x-foo" used to describe
   * extra functionality that is not covered by the standard OpenAPI Specification.
   * See: https://swagger.io/docs/specification/2-0/swagger-extensions/
   */
  extensions: { [key: string]: any | null };
}

export interface Response_HeadersEntry {
  key: string;
  value?: Header | null;
}

export interface Response_ExamplesEntry {
  key: string;
  value: string;
}

export interface Response_ExtensionsEntry {
  key: string;
  value?: any | null;
}

/**
 * `Info` is a representation of OpenAPI v2 specification's Info object.
 *
 * See: https://github.com/OAI/OpenAPI-Specification/blob/3.0.0/versions/2.0.md#infoObject
 *
 * Example:
 *
 *  option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_swagger) = {
 *    info: {
 *      title: "Echo API";
 *      version: "1.0";
 *      description: "";
 *      contact: {
 *        name: "gRPC-Gateway project";
 *        url: "https://github.com/grpc-ecosystem/grpc-gateway";
 *        email: "none@example.com";
 *      };
 *      license: {
 *        name: "BSD 3-Clause License";
 *        url: "https://github.com/grpc-ecosystem/grpc-gateway/blob/main/LICENSE";
 *      };
 *    };
 *    ...
 *  };
 */
export interface Info {
  /** The title of the application. */
  title: string;
  /**
   * A short description of the application. GFM syntax can be used for rich
   * text representation.
   */
  description: string;
  /** The Terms of Service for the API. */
  terms_of_service: string;
  /** The contact information for the exposed API. */
  contact?:
    | Contact
    | null;
  /** The license information for the exposed API. */
  license?:
    | License
    | null;
  /**
   * Provides the version of the application API (not to be confused
   * with the specification version).
   */
  version: string;
  /**
   * Custom properties that start with "x-" such as "x-foo" used to describe
   * extra functionality that is not covered by the standard OpenAPI Specification.
   * See: https://swagger.io/docs/specification/2-0/swagger-extensions/
   */
  extensions: { [key: string]: any | null };
}

export interface Info_ExtensionsEntry {
  key: string;
  value?: any | null;
}

/**
 * `Contact` is a representation of OpenAPI v2 specification's Contact object.
 *
 * See: https://github.com/OAI/OpenAPI-Specification/blob/3.0.0/versions/2.0.md#contactObject
 *
 * Example:
 *
 *  option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_swagger) = {
 *    info: {
 *      ...
 *      contact: {
 *        name: "gRPC-Gateway project";
 *        url: "https://github.com/grpc-ecosystem/grpc-gateway";
 *        email: "none@example.com";
 *      };
 *      ...
 *    };
 *    ...
 *  };
 */
export interface Contact {
  /** The identifying name of the contact person/organization. */
  name: string;
  /**
   * The URL pointing to the contact information. MUST be in the format of a
   * URL.
   */
  url: string;
  /**
   * The email address of the contact person/organization. MUST be in the format
   * of an email address.
   */
  email: string;
}

/**
 * `License` is a representation of OpenAPI v2 specification's License object.
 *
 * See: https://github.com/OAI/OpenAPI-Specification/blob/3.0.0/versions/2.0.md#licenseObject
 *
 * Example:
 *
 *  option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_swagger) = {
 *    info: {
 *      ...
 *      license: {
 *        name: "BSD 3-Clause License";
 *        url: "https://github.com/grpc-ecosystem/grpc-gateway/blob/main/LICENSE";
 *      };
 *      ...
 *    };
 *    ...
 *  };
 */
export interface License {
  /** The license name used for the API. */
  name: string;
  /** A URL to the license used for the API. MUST be in the format of a URL. */
  url: string;
}

/**
 * `ExternalDocumentation` is a representation of OpenAPI v2 specification's
 * ExternalDocumentation object.
 *
 * See: https://github.com/OAI/OpenAPI-Specification/blob/3.0.0/versions/2.0.md#externalDocumentationObject
 *
 * Example:
 *
 *  option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_swagger) = {
 *    ...
 *    external_docs: {
 *      description: "More about gRPC-Gateway";
 *      url: "https://github.com/grpc-ecosystem/grpc-gateway";
 *    }
 *    ...
 *  };
 */
export interface ExternalDocumentation {
  /**
   * A short description of the target documentation. GFM syntax can be used for
   * rich text representation.
   */
  description: string;
  /**
   * The URL for the target documentation. Value MUST be in the format
   * of a URL.
   */
  url: string;
}

/**
 * `Schema` is a representation of OpenAPI v2 specification's Schema object.
 *
 * See: https://github.com/OAI/OpenAPI-Specification/blob/3.0.0/versions/2.0.md#schemaObject
 */
export interface Schema {
  json_schema?:
    | JSONSchema
    | null;
  /**
   * Adds support for polymorphism. The discriminator is the schema property
   * name that is used to differentiate between other schema that inherit this
   * schema. The property name used MUST be defined at this schema and it MUST
   * be in the required property list. When used, the value MUST be the name of
   * this schema or any schema that inherits it.
   */
  discriminator: string;
  /**
   * Relevant only for Schema "properties" definitions. Declares the property as
   * "read only". This means that it MAY be sent as part of a response but MUST
   * NOT be sent as part of the request. Properties marked as readOnly being
   * true SHOULD NOT be in the required list of the defined schema. Default
   * value is false.
   */
  read_only: boolean;
  /** Additional external documentation for this schema. */
  external_docs?:
    | ExternalDocumentation
    | null;
  /**
   * A free-form property to include an example of an instance for this schema in JSON.
   * This is copied verbatim to the output.
   */
  example: string;
}

/**
 * `JSONSchema` represents properties from JSON Schema taken, and as used, in
 * the OpenAPI v2 spec.
 *
 * This includes changes made by OpenAPI v2.
 *
 * See: https://github.com/OAI/OpenAPI-Specification/blob/3.0.0/versions/2.0.md#schemaObject
 *
 * See also: https://cswr.github.io/JsonSchema/spec/basic_types/,
 * https://github.com/json-schema-org/json-schema-spec/blob/master/schema.json
 *
 * Example:
 *
 *  message SimpleMessage {
 *    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_schema) = {
 *      json_schema: {
 *        title: "SimpleMessage"
 *        description: "A simple message."
 *        required: ["id"]
 *      }
 *    };
 *
 *    // Id represents the message identifier.
 *    string id = 1; [
 *        (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
 *          description: "The unique identifier of the simple message."
 *        }];
 *  }
 */
export interface JSONSchema {
  /**
   * Ref is used to define an external reference to include in the message.
   * This could be a fully qualified proto message reference, and that type must
   * be imported into the protofile. If no message is identified, the Ref will
   * be used verbatim in the output.
   * For example:
   *  `ref: ".google.protobuf.Timestamp"`.
   */
  ref: string;
  /** The title of the schema. */
  title: string;
  /** A short description of the schema. */
  description: string;
  default: string;
  read_only: boolean;
  /**
   * A free-form property to include a JSON example of this field. This is copied
   * verbatim to the output swagger.json. Quotes must be escaped.
   * This property is the same for 2.0 and 3.0.0 https://github.com/OAI/OpenAPI-Specification/blob/3.0.0/versions/3.0.0.md#schemaObject  https://github.com/OAI/OpenAPI-Specification/blob/3.0.0/versions/2.0.md#schemaObject
   */
  example: string;
  multiple_of: number;
  /**
   * Maximum represents an inclusive upper limit for a numeric instance. The
   * value of MUST be a number,
   */
  maximum: number;
  exclusive_maximum: boolean;
  /**
   * minimum represents an inclusive lower limit for a numeric instance. The
   * value of MUST be a number,
   */
  minimum: number;
  exclusive_minimum: boolean;
  max_length: bigint;
  min_length: bigint;
  pattern: string;
  max_items: bigint;
  min_items: bigint;
  unique_items: boolean;
  max_properties: bigint;
  min_properties: bigint;
  required: string[];
  /** Items in 'array' must be unique. */
  array: string[];
  type: JSONSchema_JSONSchemaSimpleTypes[];
  /** `Format` */
  format: string;
  /** Items in `enum` must be unique https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-5.5.1 */
  enum: string[];
  /** Additional field level properties used when generating the OpenAPI v2 file. */
  field_configuration?:
    | JSONSchema_FieldConfiguration
    | null;
  /**
   * Custom properties that start with "x-" such as "x-foo" used to describe
   * extra functionality that is not covered by the standard OpenAPI Specification.
   * See: https://swagger.io/docs/specification/2-0/swagger-extensions/
   */
  extensions: { [key: string]: any | null };
}

export const JSONSchema_JSONSchemaSimpleTypes = {
  UNKNOWN: "UNKNOWN",
  ARRAY: "ARRAY",
  BOOLEAN: "BOOLEAN",
  INTEGER: "INTEGER",
  NULL: "NULL",
  NUMBER: "NUMBER",
  OBJECT: "OBJECT",
  STRING: "STRING",
} as const;

export type JSONSchema_JSONSchemaSimpleTypes =
  typeof JSONSchema_JSONSchemaSimpleTypes[keyof typeof JSONSchema_JSONSchemaSimpleTypes];

export namespace JSONSchema_JSONSchemaSimpleTypes {
  export type UNKNOWN = typeof JSONSchema_JSONSchemaSimpleTypes.UNKNOWN;
  export type ARRAY = typeof JSONSchema_JSONSchemaSimpleTypes.ARRAY;
  export type BOOLEAN = typeof JSONSchema_JSONSchemaSimpleTypes.BOOLEAN;
  export type INTEGER = typeof JSONSchema_JSONSchemaSimpleTypes.INTEGER;
  export type NULL = typeof JSONSchema_JSONSchemaSimpleTypes.NULL;
  export type NUMBER = typeof JSONSchema_JSONSchemaSimpleTypes.NUMBER;
  export type OBJECT = typeof JSONSchema_JSONSchemaSimpleTypes.OBJECT;
  export type STRING = typeof JSONSchema_JSONSchemaSimpleTypes.STRING;
}

export function jSONSchema_JSONSchemaSimpleTypesFromJSON(object: any): JSONSchema_JSONSchemaSimpleTypes {
  switch (object) {
    case 0:
    case "UNKNOWN":
      return JSONSchema_JSONSchemaSimpleTypes.UNKNOWN;
    case 1:
    case "ARRAY":
      return JSONSchema_JSONSchemaSimpleTypes.ARRAY;
    case 2:
    case "BOOLEAN":
      return JSONSchema_JSONSchemaSimpleTypes.BOOLEAN;
    case 3:
    case "INTEGER":
      return JSONSchema_JSONSchemaSimpleTypes.INTEGER;
    case 4:
    case "NULL":
      return JSONSchema_JSONSchemaSimpleTypes.NULL;
    case 5:
    case "NUMBER":
      return JSONSchema_JSONSchemaSimpleTypes.NUMBER;
    case 6:
    case "OBJECT":
      return JSONSchema_JSONSchemaSimpleTypes.OBJECT;
    case 7:
    case "STRING":
      return JSONSchema_JSONSchemaSimpleTypes.STRING;
    default:
      return JSONSchema_JSONSchemaSimpleTypes.UNKNOWN;
  }
}

export function jSONSchema_JSONSchemaSimpleTypesToJSON(object: JSONSchema_JSONSchemaSimpleTypes): string {
  switch (object) {
    case JSONSchema_JSONSchemaSimpleTypes.UNKNOWN:
      return "UNKNOWN";
    case JSONSchema_JSONSchemaSimpleTypes.ARRAY:
      return "ARRAY";
    case JSONSchema_JSONSchemaSimpleTypes.BOOLEAN:
      return "BOOLEAN";
    case JSONSchema_JSONSchemaSimpleTypes.INTEGER:
      return "INTEGER";
    case JSONSchema_JSONSchemaSimpleTypes.NULL:
      return "NULL";
    case JSONSchema_JSONSchemaSimpleTypes.NUMBER:
      return "NUMBER";
    case JSONSchema_JSONSchemaSimpleTypes.OBJECT:
      return "OBJECT";
    case JSONSchema_JSONSchemaSimpleTypes.STRING:
      return "STRING";
    default:
      return "UNKNOWN";
  }
}

export function jSONSchema_JSONSchemaSimpleTypesToNumber(object: JSONSchema_JSONSchemaSimpleTypes): number {
  switch (object) {
    case JSONSchema_JSONSchemaSimpleTypes.UNKNOWN:
      return 0;
    case JSONSchema_JSONSchemaSimpleTypes.ARRAY:
      return 1;
    case JSONSchema_JSONSchemaSimpleTypes.BOOLEAN:
      return 2;
    case JSONSchema_JSONSchemaSimpleTypes.INTEGER:
      return 3;
    case JSONSchema_JSONSchemaSimpleTypes.NULL:
      return 4;
    case JSONSchema_JSONSchemaSimpleTypes.NUMBER:
      return 5;
    case JSONSchema_JSONSchemaSimpleTypes.OBJECT:
      return 6;
    case JSONSchema_JSONSchemaSimpleTypes.STRING:
      return 7;
    default:
      return 0;
  }
}

/**
 * 'FieldConfiguration' provides additional field level properties used when generating the OpenAPI v2 file.
 * These properties are not defined by OpenAPIv2, but they are used to control the generation.
 */
export interface JSONSchema_FieldConfiguration {
  /**
   * Alternative parameter name when used as path parameter. If set, this will
   * be used as the complete parameter name when this field is used as a path
   * parameter. Use this to avoid having auto generated path parameter names
   * for overlapping paths.
   */
  path_param_name: string;
}

export interface JSONSchema_ExtensionsEntry {
  key: string;
  value?: any | null;
}

/**
 * `Tag` is a representation of OpenAPI v2 specification's Tag object.
 *
 * See: https://github.com/OAI/OpenAPI-Specification/blob/3.0.0/versions/2.0.md#tagObject
 */
export interface Tag {
  /**
   * The name of the tag. Use it to allow override of the name of a
   * global Tag object, then use that name to reference the tag throughout the
   * OpenAPI file.
   */
  name: string;
  /**
   * A short description for the tag. GFM syntax can be used for rich text
   * representation.
   */
  description: string;
  /** Additional external documentation for this tag. */
  external_docs?:
    | ExternalDocumentation
    | null;
  /**
   * Custom properties that start with "x-" such as "x-foo" used to describe
   * extra functionality that is not covered by the standard OpenAPI Specification.
   * See: https://swagger.io/docs/specification/2-0/swagger-extensions/
   */
  extensions: { [key: string]: any | null };
}

export interface Tag_ExtensionsEntry {
  key: string;
  value?: any | null;
}

/**
 * `SecurityDefinitions` is a representation of OpenAPI v2 specification's
 * Security Definitions object.
 *
 * See: https://github.com/OAI/OpenAPI-Specification/blob/3.0.0/versions/2.0.md#securityDefinitionsObject
 *
 * A declaration of the security schemes available to be used in the
 * specification. This does not enforce the security schemes on the operations
 * and only serves to provide the relevant details for each scheme.
 */
export interface SecurityDefinitions {
  /**
   * A single security scheme definition, mapping a "name" to the scheme it
   * defines.
   */
  security: { [key: string]: SecurityScheme };
}

export interface SecurityDefinitions_SecurityEntry {
  key: string;
  value?: SecurityScheme | null;
}

/**
 * `SecurityScheme` is a representation of OpenAPI v2 specification's
 * Security Scheme object.
 *
 * See: https://github.com/OAI/OpenAPI-Specification/blob/3.0.0/versions/2.0.md#securitySchemeObject
 *
 * Allows the definition of a security scheme that can be used by the
 * operations. Supported schemes are basic authentication, an API key (either as
 * a header or as a query parameter) and OAuth2's common flows (implicit,
 * password, application and access code).
 */
export interface SecurityScheme {
  /**
   * The type of the security scheme. Valid values are "basic",
   * "apiKey" or "oauth2".
   */
  type: SecurityScheme_Type;
  /** A short description for security scheme. */
  description: string;
  /**
   * The name of the header or query parameter to be used.
   * Valid for apiKey.
   */
  name: string;
  /**
   * The location of the API key. Valid values are "query" or
   * "header".
   * Valid for apiKey.
   */
  in: SecurityScheme_In;
  /**
   * The flow used by the OAuth2 security scheme. Valid values are
   * "implicit", "password", "application" or "accessCode".
   * Valid for oauth2.
   */
  flow: SecurityScheme_Flow;
  /**
   * The authorization URL to be used for this flow. This SHOULD be in
   * the form of a URL.
   * Valid for oauth2/implicit and oauth2/accessCode.
   */
  authorization_url: string;
  /**
   * The token URL to be used for this flow. This SHOULD be in the
   * form of a URL.
   * Valid for oauth2/password, oauth2/application and oauth2/accessCode.
   */
  token_url: string;
  /**
   * The available scopes for the OAuth2 security scheme.
   * Valid for oauth2.
   */
  scopes?:
    | Scopes
    | null;
  /**
   * Custom properties that start with "x-" such as "x-foo" used to describe
   * extra functionality that is not covered by the standard OpenAPI Specification.
   * See: https://swagger.io/docs/specification/2-0/swagger-extensions/
   */
  extensions: { [key: string]: any | null };
}

/**
 * The type of the security scheme. Valid values are "basic",
 * "apiKey" or "oauth2".
 */
export const SecurityScheme_Type = {
  INVALID: "TYPE_INVALID",
  BASIC: "TYPE_BASIC",
  API_KEY: "TYPE_API_KEY",
  OAUTH2: "TYPE_OAUTH2",
} as const;

export type SecurityScheme_Type = typeof SecurityScheme_Type[keyof typeof SecurityScheme_Type];

export namespace SecurityScheme_Type {
  export type INVALID = typeof SecurityScheme_Type.INVALID;
  export type BASIC = typeof SecurityScheme_Type.BASIC;
  export type API_KEY = typeof SecurityScheme_Type.API_KEY;
  export type OAUTH2 = typeof SecurityScheme_Type.OAUTH2;
}

export function securityScheme_TypeFromJSON(object: any): SecurityScheme_Type {
  switch (object) {
    case 0:
    case "TYPE_INVALID":
      return SecurityScheme_Type.INVALID;
    case 1:
    case "TYPE_BASIC":
      return SecurityScheme_Type.BASIC;
    case 2:
    case "TYPE_API_KEY":
      return SecurityScheme_Type.API_KEY;
    case 3:
    case "TYPE_OAUTH2":
      return SecurityScheme_Type.OAUTH2;
    default:
      return SecurityScheme_Type.INVALID;
  }
}

export function securityScheme_TypeToJSON(object: SecurityScheme_Type): string {
  switch (object) {
    case SecurityScheme_Type.INVALID:
      return "TYPE_INVALID";
    case SecurityScheme_Type.BASIC:
      return "TYPE_BASIC";
    case SecurityScheme_Type.API_KEY:
      return "TYPE_API_KEY";
    case SecurityScheme_Type.OAUTH2:
      return "TYPE_OAUTH2";
    default:
      return "INVALID";
  }
}

export function securityScheme_TypeToNumber(object: SecurityScheme_Type): number {
  switch (object) {
    case SecurityScheme_Type.INVALID:
      return 0;
    case SecurityScheme_Type.BASIC:
      return 1;
    case SecurityScheme_Type.API_KEY:
      return 2;
    case SecurityScheme_Type.OAUTH2:
      return 3;
    default:
      return 0;
  }
}

/** The location of the API key. Valid values are "query" or "header". */
export const SecurityScheme_In = { INVALID: "IN_INVALID", QUERY: "IN_QUERY", HEADER: "IN_HEADER" } as const;

export type SecurityScheme_In = typeof SecurityScheme_In[keyof typeof SecurityScheme_In];

export namespace SecurityScheme_In {
  export type INVALID = typeof SecurityScheme_In.INVALID;
  export type QUERY = typeof SecurityScheme_In.QUERY;
  export type HEADER = typeof SecurityScheme_In.HEADER;
}

export function securityScheme_InFromJSON(object: any): SecurityScheme_In {
  switch (object) {
    case 0:
    case "IN_INVALID":
      return SecurityScheme_In.INVALID;
    case 1:
    case "IN_QUERY":
      return SecurityScheme_In.QUERY;
    case 2:
    case "IN_HEADER":
      return SecurityScheme_In.HEADER;
    default:
      return SecurityScheme_In.INVALID;
  }
}

export function securityScheme_InToJSON(object: SecurityScheme_In): string {
  switch (object) {
    case SecurityScheme_In.INVALID:
      return "IN_INVALID";
    case SecurityScheme_In.QUERY:
      return "IN_QUERY";
    case SecurityScheme_In.HEADER:
      return "IN_HEADER";
    default:
      return "INVALID";
  }
}

export function securityScheme_InToNumber(object: SecurityScheme_In): number {
  switch (object) {
    case SecurityScheme_In.INVALID:
      return 0;
    case SecurityScheme_In.QUERY:
      return 1;
    case SecurityScheme_In.HEADER:
      return 2;
    default:
      return 0;
  }
}

/**
 * The flow used by the OAuth2 security scheme. Valid values are
 * "implicit", "password", "application" or "accessCode".
 */
export const SecurityScheme_Flow = {
  INVALID: "FLOW_INVALID",
  IMPLICIT: "FLOW_IMPLICIT",
  PASSWORD: "FLOW_PASSWORD",
  APPLICATION: "FLOW_APPLICATION",
  ACCESS_CODE: "FLOW_ACCESS_CODE",
} as const;

export type SecurityScheme_Flow = typeof SecurityScheme_Flow[keyof typeof SecurityScheme_Flow];

export namespace SecurityScheme_Flow {
  export type INVALID = typeof SecurityScheme_Flow.INVALID;
  export type IMPLICIT = typeof SecurityScheme_Flow.IMPLICIT;
  export type PASSWORD = typeof SecurityScheme_Flow.PASSWORD;
  export type APPLICATION = typeof SecurityScheme_Flow.APPLICATION;
  export type ACCESS_CODE = typeof SecurityScheme_Flow.ACCESS_CODE;
}

export function securityScheme_FlowFromJSON(object: any): SecurityScheme_Flow {
  switch (object) {
    case 0:
    case "FLOW_INVALID":
      return SecurityScheme_Flow.INVALID;
    case 1:
    case "FLOW_IMPLICIT":
      return SecurityScheme_Flow.IMPLICIT;
    case 2:
    case "FLOW_PASSWORD":
      return SecurityScheme_Flow.PASSWORD;
    case 3:
    case "FLOW_APPLICATION":
      return SecurityScheme_Flow.APPLICATION;
    case 4:
    case "FLOW_ACCESS_CODE":
      return SecurityScheme_Flow.ACCESS_CODE;
    default:
      return SecurityScheme_Flow.INVALID;
  }
}

export function securityScheme_FlowToJSON(object: SecurityScheme_Flow): string {
  switch (object) {
    case SecurityScheme_Flow.INVALID:
      return "FLOW_INVALID";
    case SecurityScheme_Flow.IMPLICIT:
      return "FLOW_IMPLICIT";
    case SecurityScheme_Flow.PASSWORD:
      return "FLOW_PASSWORD";
    case SecurityScheme_Flow.APPLICATION:
      return "FLOW_APPLICATION";
    case SecurityScheme_Flow.ACCESS_CODE:
      return "FLOW_ACCESS_CODE";
    default:
      return "INVALID";
  }
}

export function securityScheme_FlowToNumber(object: SecurityScheme_Flow): number {
  switch (object) {
    case SecurityScheme_Flow.INVALID:
      return 0;
    case SecurityScheme_Flow.IMPLICIT:
      return 1;
    case SecurityScheme_Flow.PASSWORD:
      return 2;
    case SecurityScheme_Flow.APPLICATION:
      return 3;
    case SecurityScheme_Flow.ACCESS_CODE:
      return 4;
    default:
      return 0;
  }
}

export interface SecurityScheme_ExtensionsEntry {
  key: string;
  value?: any | null;
}

/**
 * `SecurityRequirement` is a representation of OpenAPI v2 specification's
 * Security Requirement object.
 *
 * See: https://github.com/OAI/OpenAPI-Specification/blob/3.0.0/versions/2.0.md#securityRequirementObject
 *
 * Lists the required security schemes to execute this operation. The object can
 * have multiple security schemes declared in it which are all required (that
 * is, there is a logical AND between the schemes).
 *
 * The name used for each property MUST correspond to a security scheme
 * declared in the Security Definitions.
 */
export interface SecurityRequirement {
  /**
   * Each name must correspond to a security scheme which is declared in
   * the Security Definitions. If the security scheme is of type "oauth2",
   * then the value is a list of scope names required for the execution.
   * For other security scheme types, the array MUST be empty.
   */
  security_requirement: { [key: string]: SecurityRequirement_SecurityRequirementValue };
}

/**
 * If the security scheme is of type "oauth2", then the value is a list of
 * scope names required for the execution. For other security scheme types,
 * the array MUST be empty.
 */
export interface SecurityRequirement_SecurityRequirementValue {
  scope: string[];
}

export interface SecurityRequirement_SecurityRequirementEntry {
  key: string;
  value?: SecurityRequirement_SecurityRequirementValue | null;
}

/**
 * `Scopes` is a representation of OpenAPI v2 specification's Scopes object.
 *
 * See: https://github.com/OAI/OpenAPI-Specification/blob/3.0.0/versions/2.0.md#scopesObject
 *
 * Lists the available scopes for an OAuth2 security scheme.
 */
export interface Scopes {
  /**
   * Maps between a name of a scope to a short description of it (as the value
   * of the property).
   */
  scope: { [key: string]: string };
}

export interface Scopes_ScopeEntry {
  key: string;
  value: string;
}

function createBaseSwagger(): Swagger {
  return {
    swagger: "",
    info: null,
    host: "",
    base_path: "",
    schemes: [],
    consumes: [],
    produces: [],
    responses: {},
    security_definitions: null,
    security: [],
    tags: [],
    external_docs: null,
    extensions: {},
  };
}

export const Swagger = {
  encode(message: Swagger, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.swagger !== "") {
      writer.uint32(10).string(message.swagger);
    }
    if (message.info !== undefined && message.info !== null) {
      Info.encode(message.info, writer.uint32(18).fork()).ldelim();
    }
    if (message.host !== "") {
      writer.uint32(26).string(message.host);
    }
    if (message.base_path !== "") {
      writer.uint32(34).string(message.base_path);
    }
    writer.uint32(42).fork();
    for (const v of message.schemes) {
      writer.int32(schemeToNumber(v));
    }
    writer.ldelim();
    for (const v of message.consumes) {
      writer.uint32(50).string(v!);
    }
    for (const v of message.produces) {
      writer.uint32(58).string(v!);
    }
    Object.entries(message.responses).forEach(([key, value]) => {
      Swagger_ResponsesEntry.encode({ key: key as any, value }, writer.uint32(82).fork()).ldelim();
    });
    if (message.security_definitions !== undefined && message.security_definitions !== null) {
      SecurityDefinitions.encode(message.security_definitions, writer.uint32(90).fork()).ldelim();
    }
    for (const v of message.security) {
      SecurityRequirement.encode(v!, writer.uint32(98).fork()).ldelim();
    }
    for (const v of message.tags) {
      Tag.encode(v!, writer.uint32(106).fork()).ldelim();
    }
    if (message.external_docs !== undefined && message.external_docs !== null) {
      ExternalDocumentation.encode(message.external_docs, writer.uint32(114).fork()).ldelim();
    }
    Object.entries(message.extensions).forEach(([key, value]) => {
      if (value !== undefined || value !== null) {
        Swagger_ExtensionsEntry.encode({ key: key as any, value }, writer.uint32(122).fork()).ldelim();
      }
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Swagger {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSwagger();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.swagger = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.info = Info.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.host = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.base_path = reader.string();
          continue;
        case 5:
          if (tag === 40) {
            message.schemes.push(schemeFromJSON(reader.int32()));

            continue;
          }

          if (tag === 42) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.schemes.push(schemeFromJSON(reader.int32()));
            }

            continue;
          }

          break;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.consumes.push(reader.string());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.produces.push(reader.string());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          const entry10 = Swagger_ResponsesEntry.decode(reader, reader.uint32());
          if (entry10.value !== undefined && entry10.value !== null) {
            message.responses[entry10.key] = entry10.value;
          }
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.security_definitions = SecurityDefinitions.decode(reader, reader.uint32());
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.security.push(SecurityRequirement.decode(reader, reader.uint32()));
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.tags.push(Tag.decode(reader, reader.uint32()));
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.external_docs = ExternalDocumentation.decode(reader, reader.uint32());
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          const entry15 = Swagger_ExtensionsEntry.decode(reader, reader.uint32());
          if (entry15.value !== undefined && entry15.value !== null) {
            message.extensions[entry15.key] = entry15.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<Swagger, Uint8Array>
  async *encodeTransform(
    source: AsyncIterable<Swagger | Swagger[]> | Iterable<Swagger | Swagger[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [Swagger.encode(p).finish()];
        }
      } else {
        yield* [Swagger.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, Swagger>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<Swagger> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [Swagger.decode(p)];
        }
      } else {
        yield* [Swagger.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): Swagger {
    return {
      swagger: isSet(object.swagger) ? globalThis.String(object.swagger) : "",
      info: isSet(object.info) ? Info.fromJSON(object.info) : null,
      host: isSet(object.host) ? globalThis.String(object.host) : "",
      base_path: isSet(object.base_path) ? globalThis.String(object.base_path) : "",
      schemes: globalThis.Array.isArray(object?.schemes) ? object.schemes.map((e: any) => schemeFromJSON(e)) : [],
      consumes: globalThis.Array.isArray(object?.consumes) ? object.consumes.map((e: any) => globalThis.String(e)) : [],
      produces: globalThis.Array.isArray(object?.produces) ? object.produces.map((e: any) => globalThis.String(e)) : [],
      responses: isObject(object.responses)
        ? Object.entries(object.responses).reduce<{ [key: string]: Response }>((acc, [key, value]) => {
          acc[key] = Response.fromJSON(value);
          return acc;
        }, {})
        : {},
      security_definitions: isSet(object.security_definitions)
        ? SecurityDefinitions.fromJSON(object.security_definitions)
        : null,
      security: globalThis.Array.isArray(object?.security)
        ? object.security.map((e: any) => SecurityRequirement.fromJSON(e))
        : [],
      tags: globalThis.Array.isArray(object?.tags) ? object.tags.map((e: any) => Tag.fromJSON(e)) : [],
      external_docs: isSet(object.external_docs) ? ExternalDocumentation.fromJSON(object.external_docs) : null,
      extensions: isObject(object.extensions)
        ? Object.entries(object.extensions).reduce<{ [key: string]: any | null }>((acc, [key, value]) => {
          acc[key] = value as any | null;
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: Swagger): unknown {
    const obj: any = {};
    if (message.swagger !== "") {
      obj.swagger = message.swagger;
    }
    if (message.info !== undefined && message.info !== null) {
      obj.info = Info.toJSON(message.info);
    }
    if (message.host !== "") {
      obj.host = message.host;
    }
    if (message.base_path !== "") {
      obj.base_path = message.base_path;
    }
    if (message.schemes?.length) {
      obj.schemes = message.schemes.map((e) => schemeToJSON(e));
    }
    if (message.consumes?.length) {
      obj.consumes = message.consumes;
    }
    if (message.produces?.length) {
      obj.produces = message.produces;
    }
    if (message.responses) {
      const entries = Object.entries(message.responses);
      if (entries.length > 0) {
        obj.responses = {};
        entries.forEach(([k, v]) => {
          obj.responses[k] = Response.toJSON(v);
        });
      }
    }
    if (message.security_definitions !== undefined && message.security_definitions !== null) {
      obj.security_definitions = SecurityDefinitions.toJSON(message.security_definitions);
    }
    if (message.security?.length) {
      obj.security = message.security.map((e) => SecurityRequirement.toJSON(e));
    }
    if (message.tags?.length) {
      obj.tags = message.tags.map((e) => Tag.toJSON(e));
    }
    if (message.external_docs !== undefined && message.external_docs !== null) {
      obj.external_docs = ExternalDocumentation.toJSON(message.external_docs);
    }
    if (message.extensions) {
      const entries = Object.entries(message.extensions);
      if (entries.length > 0) {
        obj.extensions = {};
        entries.forEach(([k, v]) => {
          obj.extensions[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Swagger>, I>>(base?: I): Swagger {
    return Swagger.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Swagger>, I>>(object: I): Swagger {
    const message = createBaseSwagger();
    message.swagger = object.swagger ?? "";
    message.info = (object.info !== undefined && object.info !== null) ? Info.fromPartial(object.info) : null;
    message.host = object.host ?? "";
    message.base_path = object.base_path ?? "";
    message.schemes = object.schemes?.map((e) => e) || [];
    message.consumes = object.consumes?.map((e) => e) || [];
    message.produces = object.produces?.map((e) => e) || [];
    message.responses = Object.entries(object.responses ?? {}).reduce<{ [key: string]: Response }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = Response.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.security_definitions = (object.security_definitions !== undefined && object.security_definitions !== null)
      ? SecurityDefinitions.fromPartial(object.security_definitions)
      : null;
    message.security = object.security?.map((e) => SecurityRequirement.fromPartial(e)) || [];
    message.tags = object.tags?.map((e) => Tag.fromPartial(e)) || [];
    message.external_docs = (object.external_docs !== undefined && object.external_docs !== null)
      ? ExternalDocumentation.fromPartial(object.external_docs)
      : null;
    message.extensions = Object.entries(object.extensions ?? {}).reduce<{ [key: string]: any | null }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = value;
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseSwagger_ResponsesEntry(): Swagger_ResponsesEntry {
  return { key: "", value: null };
}

export const Swagger_ResponsesEntry = {
  encode(message: Swagger_ResponsesEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined && message.value !== null) {
      Response.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Swagger_ResponsesEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSwagger_ResponsesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = Response.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<Swagger_ResponsesEntry, Uint8Array>
  async *encodeTransform(
    source:
      | AsyncIterable<Swagger_ResponsesEntry | Swagger_ResponsesEntry[]>
      | Iterable<Swagger_ResponsesEntry | Swagger_ResponsesEntry[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [Swagger_ResponsesEntry.encode(p).finish()];
        }
      } else {
        yield* [Swagger_ResponsesEntry.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, Swagger_ResponsesEntry>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<Swagger_ResponsesEntry> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [Swagger_ResponsesEntry.decode(p)];
        }
      } else {
        yield* [Swagger_ResponsesEntry.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): Swagger_ResponsesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? Response.fromJSON(object.value) : null,
    };
  },

  toJSON(message: Swagger_ResponsesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined && message.value !== null) {
      obj.value = Response.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Swagger_ResponsesEntry>, I>>(base?: I): Swagger_ResponsesEntry {
    return Swagger_ResponsesEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Swagger_ResponsesEntry>, I>>(object: I): Swagger_ResponsesEntry {
    const message = createBaseSwagger_ResponsesEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null) ? Response.fromPartial(object.value) : null;
    return message;
  },
};

function createBaseSwagger_ExtensionsEntry(): Swagger_ExtensionsEntry {
  return { key: "", value: null };
}

export const Swagger_ExtensionsEntry = {
  encode(message: Swagger_ExtensionsEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined && message.value !== null) {
      Value.encode(Value.wrap(message.value), writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Swagger_ExtensionsEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSwagger_ExtensionsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = Value.unwrap(Value.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<Swagger_ExtensionsEntry, Uint8Array>
  async *encodeTransform(
    source:
      | AsyncIterable<Swagger_ExtensionsEntry | Swagger_ExtensionsEntry[]>
      | Iterable<Swagger_ExtensionsEntry | Swagger_ExtensionsEntry[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [Swagger_ExtensionsEntry.encode(p).finish()];
        }
      } else {
        yield* [Swagger_ExtensionsEntry.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, Swagger_ExtensionsEntry>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<Swagger_ExtensionsEntry> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [Swagger_ExtensionsEntry.decode(p)];
        }
      } else {
        yield* [Swagger_ExtensionsEntry.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): Swagger_ExtensionsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object?.value) ? object.value : null,
    };
  },

  toJSON(message: Swagger_ExtensionsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined && message.value !== null) {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Swagger_ExtensionsEntry>, I>>(base?: I): Swagger_ExtensionsEntry {
    return Swagger_ExtensionsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Swagger_ExtensionsEntry>, I>>(object: I): Swagger_ExtensionsEntry {
    const message = createBaseSwagger_ExtensionsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? null;
    return message;
  },
};

function createBaseOperation(): Operation {
  return {
    tags: [],
    summary: "",
    description: "",
    external_docs: null,
    operation_id: "",
    consumes: [],
    produces: [],
    responses: {},
    schemes: [],
    deprecated: false,
    security: [],
    extensions: {},
    parameters: null,
  };
}

export const Operation = {
  encode(message: Operation, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.tags) {
      writer.uint32(10).string(v!);
    }
    if (message.summary !== "") {
      writer.uint32(18).string(message.summary);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.external_docs !== undefined && message.external_docs !== null) {
      ExternalDocumentation.encode(message.external_docs, writer.uint32(34).fork()).ldelim();
    }
    if (message.operation_id !== "") {
      writer.uint32(42).string(message.operation_id);
    }
    for (const v of message.consumes) {
      writer.uint32(50).string(v!);
    }
    for (const v of message.produces) {
      writer.uint32(58).string(v!);
    }
    Object.entries(message.responses).forEach(([key, value]) => {
      Operation_ResponsesEntry.encode({ key: key as any, value }, writer.uint32(74).fork()).ldelim();
    });
    writer.uint32(82).fork();
    for (const v of message.schemes) {
      writer.int32(schemeToNumber(v));
    }
    writer.ldelim();
    if (message.deprecated !== false) {
      writer.uint32(88).bool(message.deprecated);
    }
    for (const v of message.security) {
      SecurityRequirement.encode(v!, writer.uint32(98).fork()).ldelim();
    }
    Object.entries(message.extensions).forEach(([key, value]) => {
      if (value !== undefined || value !== null) {
        Operation_ExtensionsEntry.encode({ key: key as any, value }, writer.uint32(106).fork()).ldelim();
      }
    });
    if (message.parameters !== undefined && message.parameters !== null) {
      Parameters.encode(message.parameters, writer.uint32(114).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Operation {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOperation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.tags.push(reader.string());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.summary = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.external_docs = ExternalDocumentation.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.operation_id = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.consumes.push(reader.string());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.produces.push(reader.string());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          const entry9 = Operation_ResponsesEntry.decode(reader, reader.uint32());
          if (entry9.value !== undefined && entry9.value !== null) {
            message.responses[entry9.key] = entry9.value;
          }
          continue;
        case 10:
          if (tag === 80) {
            message.schemes.push(schemeFromJSON(reader.int32()));

            continue;
          }

          if (tag === 82) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.schemes.push(schemeFromJSON(reader.int32()));
            }

            continue;
          }

          break;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.deprecated = reader.bool();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.security.push(SecurityRequirement.decode(reader, reader.uint32()));
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          const entry13 = Operation_ExtensionsEntry.decode(reader, reader.uint32());
          if (entry13.value !== undefined && entry13.value !== null) {
            message.extensions[entry13.key] = entry13.value;
          }
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.parameters = Parameters.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<Operation, Uint8Array>
  async *encodeTransform(
    source: AsyncIterable<Operation | Operation[]> | Iterable<Operation | Operation[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [Operation.encode(p).finish()];
        }
      } else {
        yield* [Operation.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, Operation>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<Operation> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [Operation.decode(p)];
        }
      } else {
        yield* [Operation.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): Operation {
    return {
      tags: globalThis.Array.isArray(object?.tags) ? object.tags.map((e: any) => globalThis.String(e)) : [],
      summary: isSet(object.summary) ? globalThis.String(object.summary) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      external_docs: isSet(object.external_docs) ? ExternalDocumentation.fromJSON(object.external_docs) : null,
      operation_id: isSet(object.operation_id) ? globalThis.String(object.operation_id) : "",
      consumes: globalThis.Array.isArray(object?.consumes) ? object.consumes.map((e: any) => globalThis.String(e)) : [],
      produces: globalThis.Array.isArray(object?.produces) ? object.produces.map((e: any) => globalThis.String(e)) : [],
      responses: isObject(object.responses)
        ? Object.entries(object.responses).reduce<{ [key: string]: Response }>((acc, [key, value]) => {
          acc[key] = Response.fromJSON(value);
          return acc;
        }, {})
        : {},
      schemes: globalThis.Array.isArray(object?.schemes) ? object.schemes.map((e: any) => schemeFromJSON(e)) : [],
      deprecated: isSet(object.deprecated) ? globalThis.Boolean(object.deprecated) : false,
      security: globalThis.Array.isArray(object?.security)
        ? object.security.map((e: any) => SecurityRequirement.fromJSON(e))
        : [],
      extensions: isObject(object.extensions)
        ? Object.entries(object.extensions).reduce<{ [key: string]: any | null }>((acc, [key, value]) => {
          acc[key] = value as any | null;
          return acc;
        }, {})
        : {},
      parameters: isSet(object.parameters) ? Parameters.fromJSON(object.parameters) : null,
    };
  },

  toJSON(message: Operation): unknown {
    const obj: any = {};
    if (message.tags?.length) {
      obj.tags = message.tags;
    }
    if (message.summary !== "") {
      obj.summary = message.summary;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.external_docs !== undefined && message.external_docs !== null) {
      obj.external_docs = ExternalDocumentation.toJSON(message.external_docs);
    }
    if (message.operation_id !== "") {
      obj.operation_id = message.operation_id;
    }
    if (message.consumes?.length) {
      obj.consumes = message.consumes;
    }
    if (message.produces?.length) {
      obj.produces = message.produces;
    }
    if (message.responses) {
      const entries = Object.entries(message.responses);
      if (entries.length > 0) {
        obj.responses = {};
        entries.forEach(([k, v]) => {
          obj.responses[k] = Response.toJSON(v);
        });
      }
    }
    if (message.schemes?.length) {
      obj.schemes = message.schemes.map((e) => schemeToJSON(e));
    }
    if (message.deprecated !== false) {
      obj.deprecated = message.deprecated;
    }
    if (message.security?.length) {
      obj.security = message.security.map((e) => SecurityRequirement.toJSON(e));
    }
    if (message.extensions) {
      const entries = Object.entries(message.extensions);
      if (entries.length > 0) {
        obj.extensions = {};
        entries.forEach(([k, v]) => {
          obj.extensions[k] = v;
        });
      }
    }
    if (message.parameters !== undefined && message.parameters !== null) {
      obj.parameters = Parameters.toJSON(message.parameters);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Operation>, I>>(base?: I): Operation {
    return Operation.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Operation>, I>>(object: I): Operation {
    const message = createBaseOperation();
    message.tags = object.tags?.map((e) => e) || [];
    message.summary = object.summary ?? "";
    message.description = object.description ?? "";
    message.external_docs = (object.external_docs !== undefined && object.external_docs !== null)
      ? ExternalDocumentation.fromPartial(object.external_docs)
      : null;
    message.operation_id = object.operation_id ?? "";
    message.consumes = object.consumes?.map((e) => e) || [];
    message.produces = object.produces?.map((e) => e) || [];
    message.responses = Object.entries(object.responses ?? {}).reduce<{ [key: string]: Response }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = Response.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.schemes = object.schemes?.map((e) => e) || [];
    message.deprecated = object.deprecated ?? false;
    message.security = object.security?.map((e) => SecurityRequirement.fromPartial(e)) || [];
    message.extensions = Object.entries(object.extensions ?? {}).reduce<{ [key: string]: any | null }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = value;
        }
        return acc;
      },
      {},
    );
    message.parameters = (object.parameters !== undefined && object.parameters !== null)
      ? Parameters.fromPartial(object.parameters)
      : null;
    return message;
  },
};

function createBaseOperation_ResponsesEntry(): Operation_ResponsesEntry {
  return { key: "", value: null };
}

export const Operation_ResponsesEntry = {
  encode(message: Operation_ResponsesEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined && message.value !== null) {
      Response.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Operation_ResponsesEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOperation_ResponsesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = Response.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<Operation_ResponsesEntry, Uint8Array>
  async *encodeTransform(
    source:
      | AsyncIterable<Operation_ResponsesEntry | Operation_ResponsesEntry[]>
      | Iterable<Operation_ResponsesEntry | Operation_ResponsesEntry[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [Operation_ResponsesEntry.encode(p).finish()];
        }
      } else {
        yield* [Operation_ResponsesEntry.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, Operation_ResponsesEntry>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<Operation_ResponsesEntry> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [Operation_ResponsesEntry.decode(p)];
        }
      } else {
        yield* [Operation_ResponsesEntry.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): Operation_ResponsesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? Response.fromJSON(object.value) : null,
    };
  },

  toJSON(message: Operation_ResponsesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined && message.value !== null) {
      obj.value = Response.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Operation_ResponsesEntry>, I>>(base?: I): Operation_ResponsesEntry {
    return Operation_ResponsesEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Operation_ResponsesEntry>, I>>(object: I): Operation_ResponsesEntry {
    const message = createBaseOperation_ResponsesEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null) ? Response.fromPartial(object.value) : null;
    return message;
  },
};

function createBaseOperation_ExtensionsEntry(): Operation_ExtensionsEntry {
  return { key: "", value: null };
}

export const Operation_ExtensionsEntry = {
  encode(message: Operation_ExtensionsEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined && message.value !== null) {
      Value.encode(Value.wrap(message.value), writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Operation_ExtensionsEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOperation_ExtensionsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = Value.unwrap(Value.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<Operation_ExtensionsEntry, Uint8Array>
  async *encodeTransform(
    source:
      | AsyncIterable<Operation_ExtensionsEntry | Operation_ExtensionsEntry[]>
      | Iterable<Operation_ExtensionsEntry | Operation_ExtensionsEntry[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [Operation_ExtensionsEntry.encode(p).finish()];
        }
      } else {
        yield* [Operation_ExtensionsEntry.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, Operation_ExtensionsEntry>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<Operation_ExtensionsEntry> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [Operation_ExtensionsEntry.decode(p)];
        }
      } else {
        yield* [Operation_ExtensionsEntry.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): Operation_ExtensionsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object?.value) ? object.value : null,
    };
  },

  toJSON(message: Operation_ExtensionsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined && message.value !== null) {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Operation_ExtensionsEntry>, I>>(base?: I): Operation_ExtensionsEntry {
    return Operation_ExtensionsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Operation_ExtensionsEntry>, I>>(object: I): Operation_ExtensionsEntry {
    const message = createBaseOperation_ExtensionsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? null;
    return message;
  },
};

function createBaseParameters(): Parameters {
  return { headers: [] };
}

export const Parameters = {
  encode(message: Parameters, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.headers) {
      HeaderParameter.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Parameters {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseParameters();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.headers.push(HeaderParameter.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<Parameters, Uint8Array>
  async *encodeTransform(
    source: AsyncIterable<Parameters | Parameters[]> | Iterable<Parameters | Parameters[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [Parameters.encode(p).finish()];
        }
      } else {
        yield* [Parameters.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, Parameters>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<Parameters> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [Parameters.decode(p)];
        }
      } else {
        yield* [Parameters.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): Parameters {
    return {
      headers: globalThis.Array.isArray(object?.headers)
        ? object.headers.map((e: any) => HeaderParameter.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Parameters): unknown {
    const obj: any = {};
    if (message.headers?.length) {
      obj.headers = message.headers.map((e) => HeaderParameter.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Parameters>, I>>(base?: I): Parameters {
    return Parameters.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Parameters>, I>>(object: I): Parameters {
    const message = createBaseParameters();
    message.headers = object.headers?.map((e) => HeaderParameter.fromPartial(e)) || [];
    return message;
  },
};

function createBaseHeaderParameter(): HeaderParameter {
  return { name: "", description: "", type: HeaderParameter_Type.UNKNOWN, format: "", required: false };
}

export const HeaderParameter = {
  encode(message: HeaderParameter, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    if (message.type !== HeaderParameter_Type.UNKNOWN) {
      writer.uint32(24).int32(headerParameter_TypeToNumber(message.type));
    }
    if (message.format !== "") {
      writer.uint32(34).string(message.format);
    }
    if (message.required !== false) {
      writer.uint32(40).bool(message.required);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): HeaderParameter {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHeaderParameter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.type = headerParameter_TypeFromJSON(reader.int32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.format = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.required = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<HeaderParameter, Uint8Array>
  async *encodeTransform(
    source: AsyncIterable<HeaderParameter | HeaderParameter[]> | Iterable<HeaderParameter | HeaderParameter[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [HeaderParameter.encode(p).finish()];
        }
      } else {
        yield* [HeaderParameter.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, HeaderParameter>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<HeaderParameter> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [HeaderParameter.decode(p)];
        }
      } else {
        yield* [HeaderParameter.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): HeaderParameter {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      type: isSet(object.type) ? headerParameter_TypeFromJSON(object.type) : HeaderParameter_Type.UNKNOWN,
      format: isSet(object.format) ? globalThis.String(object.format) : "",
      required: isSet(object.required) ? globalThis.Boolean(object.required) : false,
    };
  },

  toJSON(message: HeaderParameter): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.type !== HeaderParameter_Type.UNKNOWN) {
      obj.type = headerParameter_TypeToJSON(message.type);
    }
    if (message.format !== "") {
      obj.format = message.format;
    }
    if (message.required !== false) {
      obj.required = message.required;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HeaderParameter>, I>>(base?: I): HeaderParameter {
    return HeaderParameter.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HeaderParameter>, I>>(object: I): HeaderParameter {
    const message = createBaseHeaderParameter();
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    message.type = object.type ?? HeaderParameter_Type.UNKNOWN;
    message.format = object.format ?? "";
    message.required = object.required ?? false;
    return message;
  },
};

function createBaseHeader(): Header {
  return { description: "", type: "", format: "", default: "", pattern: "" };
}

export const Header = {
  encode(message: Header, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.description !== "") {
      writer.uint32(10).string(message.description);
    }
    if (message.type !== "") {
      writer.uint32(18).string(message.type);
    }
    if (message.format !== "") {
      writer.uint32(26).string(message.format);
    }
    if (message.default !== "") {
      writer.uint32(50).string(message.default);
    }
    if (message.pattern !== "") {
      writer.uint32(106).string(message.pattern);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Header {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHeader();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.description = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.type = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.format = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.default = reader.string();
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.pattern = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<Header, Uint8Array>
  async *encodeTransform(
    source: AsyncIterable<Header | Header[]> | Iterable<Header | Header[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [Header.encode(p).finish()];
        }
      } else {
        yield* [Header.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, Header>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<Header> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [Header.decode(p)];
        }
      } else {
        yield* [Header.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): Header {
    return {
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      format: isSet(object.format) ? globalThis.String(object.format) : "",
      default: isSet(object.default) ? globalThis.String(object.default) : "",
      pattern: isSet(object.pattern) ? globalThis.String(object.pattern) : "",
    };
  },

  toJSON(message: Header): unknown {
    const obj: any = {};
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.format !== "") {
      obj.format = message.format;
    }
    if (message.default !== "") {
      obj.default = message.default;
    }
    if (message.pattern !== "") {
      obj.pattern = message.pattern;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Header>, I>>(base?: I): Header {
    return Header.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Header>, I>>(object: I): Header {
    const message = createBaseHeader();
    message.description = object.description ?? "";
    message.type = object.type ?? "";
    message.format = object.format ?? "";
    message.default = object.default ?? "";
    message.pattern = object.pattern ?? "";
    return message;
  },
};

function createBaseResponse(): Response {
  return { description: "", schema: null, headers: {}, examples: {}, extensions: {} };
}

export const Response = {
  encode(message: Response, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.description !== "") {
      writer.uint32(10).string(message.description);
    }
    if (message.schema !== undefined && message.schema !== null) {
      Schema.encode(message.schema, writer.uint32(18).fork()).ldelim();
    }
    Object.entries(message.headers).forEach(([key, value]) => {
      Response_HeadersEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).ldelim();
    });
    Object.entries(message.examples).forEach(([key, value]) => {
      Response_ExamplesEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).ldelim();
    });
    Object.entries(message.extensions).forEach(([key, value]) => {
      if (value !== undefined || value !== null) {
        Response_ExtensionsEntry.encode({ key: key as any, value }, writer.uint32(42).fork()).ldelim();
      }
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Response {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.description = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.schema = Schema.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          const entry3 = Response_HeadersEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined && entry3.value !== null) {
            message.headers[entry3.key] = entry3.value;
          }
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          const entry4 = Response_ExamplesEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined && entry4.value !== null) {
            message.examples[entry4.key] = entry4.value;
          }
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          const entry5 = Response_ExtensionsEntry.decode(reader, reader.uint32());
          if (entry5.value !== undefined && entry5.value !== null) {
            message.extensions[entry5.key] = entry5.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<Response, Uint8Array>
  async *encodeTransform(
    source: AsyncIterable<Response | Response[]> | Iterable<Response | Response[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [Response.encode(p).finish()];
        }
      } else {
        yield* [Response.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, Response>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<Response> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [Response.decode(p)];
        }
      } else {
        yield* [Response.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): Response {
    return {
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      schema: isSet(object.schema) ? Schema.fromJSON(object.schema) : null,
      headers: isObject(object.headers)
        ? Object.entries(object.headers).reduce<{ [key: string]: Header }>((acc, [key, value]) => {
          acc[key] = Header.fromJSON(value);
          return acc;
        }, {})
        : {},
      examples: isObject(object.examples)
        ? Object.entries(object.examples).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      extensions: isObject(object.extensions)
        ? Object.entries(object.extensions).reduce<{ [key: string]: any | null }>((acc, [key, value]) => {
          acc[key] = value as any | null;
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: Response): unknown {
    const obj: any = {};
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.schema !== undefined && message.schema !== null) {
      obj.schema = Schema.toJSON(message.schema);
    }
    if (message.headers) {
      const entries = Object.entries(message.headers);
      if (entries.length > 0) {
        obj.headers = {};
        entries.forEach(([k, v]) => {
          obj.headers[k] = Header.toJSON(v);
        });
      }
    }
    if (message.examples) {
      const entries = Object.entries(message.examples);
      if (entries.length > 0) {
        obj.examples = {};
        entries.forEach(([k, v]) => {
          obj.examples[k] = v;
        });
      }
    }
    if (message.extensions) {
      const entries = Object.entries(message.extensions);
      if (entries.length > 0) {
        obj.extensions = {};
        entries.forEach(([k, v]) => {
          obj.extensions[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Response>, I>>(base?: I): Response {
    return Response.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Response>, I>>(object: I): Response {
    const message = createBaseResponse();
    message.description = object.description ?? "";
    message.schema = (object.schema !== undefined && object.schema !== null) ? Schema.fromPartial(object.schema) : null;
    message.headers = Object.entries(object.headers ?? {}).reduce<{ [key: string]: Header }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = Header.fromPartial(value);
      }
      return acc;
    }, {});
    message.examples = Object.entries(object.examples ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.extensions = Object.entries(object.extensions ?? {}).reduce<{ [key: string]: any | null }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = value;
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseResponse_HeadersEntry(): Response_HeadersEntry {
  return { key: "", value: null };
}

export const Response_HeadersEntry = {
  encode(message: Response_HeadersEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined && message.value !== null) {
      Header.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Response_HeadersEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResponse_HeadersEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = Header.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<Response_HeadersEntry, Uint8Array>
  async *encodeTransform(
    source:
      | AsyncIterable<Response_HeadersEntry | Response_HeadersEntry[]>
      | Iterable<Response_HeadersEntry | Response_HeadersEntry[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [Response_HeadersEntry.encode(p).finish()];
        }
      } else {
        yield* [Response_HeadersEntry.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, Response_HeadersEntry>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<Response_HeadersEntry> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [Response_HeadersEntry.decode(p)];
        }
      } else {
        yield* [Response_HeadersEntry.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): Response_HeadersEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? Header.fromJSON(object.value) : null,
    };
  },

  toJSON(message: Response_HeadersEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined && message.value !== null) {
      obj.value = Header.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Response_HeadersEntry>, I>>(base?: I): Response_HeadersEntry {
    return Response_HeadersEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Response_HeadersEntry>, I>>(object: I): Response_HeadersEntry {
    const message = createBaseResponse_HeadersEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null) ? Header.fromPartial(object.value) : null;
    return message;
  },
};

function createBaseResponse_ExamplesEntry(): Response_ExamplesEntry {
  return { key: "", value: "" };
}

export const Response_ExamplesEntry = {
  encode(message: Response_ExamplesEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Response_ExamplesEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResponse_ExamplesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<Response_ExamplesEntry, Uint8Array>
  async *encodeTransform(
    source:
      | AsyncIterable<Response_ExamplesEntry | Response_ExamplesEntry[]>
      | Iterable<Response_ExamplesEntry | Response_ExamplesEntry[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [Response_ExamplesEntry.encode(p).finish()];
        }
      } else {
        yield* [Response_ExamplesEntry.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, Response_ExamplesEntry>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<Response_ExamplesEntry> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [Response_ExamplesEntry.decode(p)];
        }
      } else {
        yield* [Response_ExamplesEntry.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): Response_ExamplesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Response_ExamplesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Response_ExamplesEntry>, I>>(base?: I): Response_ExamplesEntry {
    return Response_ExamplesEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Response_ExamplesEntry>, I>>(object: I): Response_ExamplesEntry {
    const message = createBaseResponse_ExamplesEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseResponse_ExtensionsEntry(): Response_ExtensionsEntry {
  return { key: "", value: null };
}

export const Response_ExtensionsEntry = {
  encode(message: Response_ExtensionsEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined && message.value !== null) {
      Value.encode(Value.wrap(message.value), writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Response_ExtensionsEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResponse_ExtensionsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = Value.unwrap(Value.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<Response_ExtensionsEntry, Uint8Array>
  async *encodeTransform(
    source:
      | AsyncIterable<Response_ExtensionsEntry | Response_ExtensionsEntry[]>
      | Iterable<Response_ExtensionsEntry | Response_ExtensionsEntry[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [Response_ExtensionsEntry.encode(p).finish()];
        }
      } else {
        yield* [Response_ExtensionsEntry.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, Response_ExtensionsEntry>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<Response_ExtensionsEntry> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [Response_ExtensionsEntry.decode(p)];
        }
      } else {
        yield* [Response_ExtensionsEntry.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): Response_ExtensionsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object?.value) ? object.value : null,
    };
  },

  toJSON(message: Response_ExtensionsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined && message.value !== null) {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Response_ExtensionsEntry>, I>>(base?: I): Response_ExtensionsEntry {
    return Response_ExtensionsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Response_ExtensionsEntry>, I>>(object: I): Response_ExtensionsEntry {
    const message = createBaseResponse_ExtensionsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? null;
    return message;
  },
};

function createBaseInfo(): Info {
  return {
    title: "",
    description: "",
    terms_of_service: "",
    contact: null,
    license: null,
    version: "",
    extensions: {},
  };
}

export const Info = {
  encode(message: Info, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.title !== "") {
      writer.uint32(10).string(message.title);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    if (message.terms_of_service !== "") {
      writer.uint32(26).string(message.terms_of_service);
    }
    if (message.contact !== undefined && message.contact !== null) {
      Contact.encode(message.contact, writer.uint32(34).fork()).ldelim();
    }
    if (message.license !== undefined && message.license !== null) {
      License.encode(message.license, writer.uint32(42).fork()).ldelim();
    }
    if (message.version !== "") {
      writer.uint32(50).string(message.version);
    }
    Object.entries(message.extensions).forEach(([key, value]) => {
      if (value !== undefined || value !== null) {
        Info_ExtensionsEntry.encode({ key: key as any, value }, writer.uint32(58).fork()).ldelim();
      }
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Info {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.title = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.terms_of_service = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.contact = Contact.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.license = License.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.version = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          const entry7 = Info_ExtensionsEntry.decode(reader, reader.uint32());
          if (entry7.value !== undefined && entry7.value !== null) {
            message.extensions[entry7.key] = entry7.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<Info, Uint8Array>
  async *encodeTransform(source: AsyncIterable<Info | Info[]> | Iterable<Info | Info[]>): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [Info.encode(p).finish()];
        }
      } else {
        yield* [Info.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, Info>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<Info> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [Info.decode(p)];
        }
      } else {
        yield* [Info.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): Info {
    return {
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      terms_of_service: isSet(object.terms_of_service) ? globalThis.String(object.terms_of_service) : "",
      contact: isSet(object.contact) ? Contact.fromJSON(object.contact) : null,
      license: isSet(object.license) ? License.fromJSON(object.license) : null,
      version: isSet(object.version) ? globalThis.String(object.version) : "",
      extensions: isObject(object.extensions)
        ? Object.entries(object.extensions).reduce<{ [key: string]: any | null }>((acc, [key, value]) => {
          acc[key] = value as any | null;
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: Info): unknown {
    const obj: any = {};
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.terms_of_service !== "") {
      obj.terms_of_service = message.terms_of_service;
    }
    if (message.contact !== undefined && message.contact !== null) {
      obj.contact = Contact.toJSON(message.contact);
    }
    if (message.license !== undefined && message.license !== null) {
      obj.license = License.toJSON(message.license);
    }
    if (message.version !== "") {
      obj.version = message.version;
    }
    if (message.extensions) {
      const entries = Object.entries(message.extensions);
      if (entries.length > 0) {
        obj.extensions = {};
        entries.forEach(([k, v]) => {
          obj.extensions[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Info>, I>>(base?: I): Info {
    return Info.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Info>, I>>(object: I): Info {
    const message = createBaseInfo();
    message.title = object.title ?? "";
    message.description = object.description ?? "";
    message.terms_of_service = object.terms_of_service ?? "";
    message.contact = (object.contact !== undefined && object.contact !== null)
      ? Contact.fromPartial(object.contact)
      : null;
    message.license = (object.license !== undefined && object.license !== null)
      ? License.fromPartial(object.license)
      : null;
    message.version = object.version ?? "";
    message.extensions = Object.entries(object.extensions ?? {}).reduce<{ [key: string]: any | null }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = value;
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseInfo_ExtensionsEntry(): Info_ExtensionsEntry {
  return { key: "", value: null };
}

export const Info_ExtensionsEntry = {
  encode(message: Info_ExtensionsEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined && message.value !== null) {
      Value.encode(Value.wrap(message.value), writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Info_ExtensionsEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInfo_ExtensionsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = Value.unwrap(Value.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<Info_ExtensionsEntry, Uint8Array>
  async *encodeTransform(
    source:
      | AsyncIterable<Info_ExtensionsEntry | Info_ExtensionsEntry[]>
      | Iterable<Info_ExtensionsEntry | Info_ExtensionsEntry[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [Info_ExtensionsEntry.encode(p).finish()];
        }
      } else {
        yield* [Info_ExtensionsEntry.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, Info_ExtensionsEntry>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<Info_ExtensionsEntry> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [Info_ExtensionsEntry.decode(p)];
        }
      } else {
        yield* [Info_ExtensionsEntry.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): Info_ExtensionsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object?.value) ? object.value : null,
    };
  },

  toJSON(message: Info_ExtensionsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined && message.value !== null) {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Info_ExtensionsEntry>, I>>(base?: I): Info_ExtensionsEntry {
    return Info_ExtensionsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Info_ExtensionsEntry>, I>>(object: I): Info_ExtensionsEntry {
    const message = createBaseInfo_ExtensionsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? null;
    return message;
  },
};

function createBaseContact(): Contact {
  return { name: "", url: "", email: "" };
}

export const Contact = {
  encode(message: Contact, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.url !== "") {
      writer.uint32(18).string(message.url);
    }
    if (message.email !== "") {
      writer.uint32(26).string(message.email);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Contact {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseContact();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.url = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.email = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<Contact, Uint8Array>
  async *encodeTransform(
    source: AsyncIterable<Contact | Contact[]> | Iterable<Contact | Contact[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [Contact.encode(p).finish()];
        }
      } else {
        yield* [Contact.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, Contact>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<Contact> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [Contact.decode(p)];
        }
      } else {
        yield* [Contact.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): Contact {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      url: isSet(object.url) ? globalThis.String(object.url) : "",
      email: isSet(object.email) ? globalThis.String(object.email) : "",
    };
  },

  toJSON(message: Contact): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.url !== "") {
      obj.url = message.url;
    }
    if (message.email !== "") {
      obj.email = message.email;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Contact>, I>>(base?: I): Contact {
    return Contact.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Contact>, I>>(object: I): Contact {
    const message = createBaseContact();
    message.name = object.name ?? "";
    message.url = object.url ?? "";
    message.email = object.email ?? "";
    return message;
  },
};

function createBaseLicense(): License {
  return { name: "", url: "" };
}

export const License = {
  encode(message: License, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.url !== "") {
      writer.uint32(18).string(message.url);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): License {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLicense();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.url = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<License, Uint8Array>
  async *encodeTransform(
    source: AsyncIterable<License | License[]> | Iterable<License | License[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [License.encode(p).finish()];
        }
      } else {
        yield* [License.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, License>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<License> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [License.decode(p)];
        }
      } else {
        yield* [License.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): License {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      url: isSet(object.url) ? globalThis.String(object.url) : "",
    };
  },

  toJSON(message: License): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.url !== "") {
      obj.url = message.url;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<License>, I>>(base?: I): License {
    return License.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<License>, I>>(object: I): License {
    const message = createBaseLicense();
    message.name = object.name ?? "";
    message.url = object.url ?? "";
    return message;
  },
};

function createBaseExternalDocumentation(): ExternalDocumentation {
  return { description: "", url: "" };
}

export const ExternalDocumentation = {
  encode(message: ExternalDocumentation, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.description !== "") {
      writer.uint32(10).string(message.description);
    }
    if (message.url !== "") {
      writer.uint32(18).string(message.url);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ExternalDocumentation {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExternalDocumentation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.description = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.url = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<ExternalDocumentation, Uint8Array>
  async *encodeTransform(
    source:
      | AsyncIterable<ExternalDocumentation | ExternalDocumentation[]>
      | Iterable<ExternalDocumentation | ExternalDocumentation[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [ExternalDocumentation.encode(p).finish()];
        }
      } else {
        yield* [ExternalDocumentation.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, ExternalDocumentation>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<ExternalDocumentation> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [ExternalDocumentation.decode(p)];
        }
      } else {
        yield* [ExternalDocumentation.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): ExternalDocumentation {
    return {
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      url: isSet(object.url) ? globalThis.String(object.url) : "",
    };
  },

  toJSON(message: ExternalDocumentation): unknown {
    const obj: any = {};
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.url !== "") {
      obj.url = message.url;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ExternalDocumentation>, I>>(base?: I): ExternalDocumentation {
    return ExternalDocumentation.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ExternalDocumentation>, I>>(object: I): ExternalDocumentation {
    const message = createBaseExternalDocumentation();
    message.description = object.description ?? "";
    message.url = object.url ?? "";
    return message;
  },
};

function createBaseSchema(): Schema {
  return { json_schema: null, discriminator: "", read_only: false, external_docs: null, example: "" };
}

export const Schema = {
  encode(message: Schema, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.json_schema !== undefined && message.json_schema !== null) {
      JSONSchema.encode(message.json_schema, writer.uint32(10).fork()).ldelim();
    }
    if (message.discriminator !== "") {
      writer.uint32(18).string(message.discriminator);
    }
    if (message.read_only !== false) {
      writer.uint32(24).bool(message.read_only);
    }
    if (message.external_docs !== undefined && message.external_docs !== null) {
      ExternalDocumentation.encode(message.external_docs, writer.uint32(42).fork()).ldelim();
    }
    if (message.example !== "") {
      writer.uint32(50).string(message.example);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Schema {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSchema();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.json_schema = JSONSchema.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.discriminator = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.read_only = reader.bool();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.external_docs = ExternalDocumentation.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.example = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<Schema, Uint8Array>
  async *encodeTransform(
    source: AsyncIterable<Schema | Schema[]> | Iterable<Schema | Schema[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [Schema.encode(p).finish()];
        }
      } else {
        yield* [Schema.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, Schema>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<Schema> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [Schema.decode(p)];
        }
      } else {
        yield* [Schema.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): Schema {
    return {
      json_schema: isSet(object.json_schema) ? JSONSchema.fromJSON(object.json_schema) : null,
      discriminator: isSet(object.discriminator) ? globalThis.String(object.discriminator) : "",
      read_only: isSet(object.read_only) ? globalThis.Boolean(object.read_only) : false,
      external_docs: isSet(object.external_docs) ? ExternalDocumentation.fromJSON(object.external_docs) : null,
      example: isSet(object.example) ? globalThis.String(object.example) : "",
    };
  },

  toJSON(message: Schema): unknown {
    const obj: any = {};
    if (message.json_schema !== undefined && message.json_schema !== null) {
      obj.json_schema = JSONSchema.toJSON(message.json_schema);
    }
    if (message.discriminator !== "") {
      obj.discriminator = message.discriminator;
    }
    if (message.read_only !== false) {
      obj.read_only = message.read_only;
    }
    if (message.external_docs !== undefined && message.external_docs !== null) {
      obj.external_docs = ExternalDocumentation.toJSON(message.external_docs);
    }
    if (message.example !== "") {
      obj.example = message.example;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Schema>, I>>(base?: I): Schema {
    return Schema.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Schema>, I>>(object: I): Schema {
    const message = createBaseSchema();
    message.json_schema = (object.json_schema !== undefined && object.json_schema !== null)
      ? JSONSchema.fromPartial(object.json_schema)
      : null;
    message.discriminator = object.discriminator ?? "";
    message.read_only = object.read_only ?? false;
    message.external_docs = (object.external_docs !== undefined && object.external_docs !== null)
      ? ExternalDocumentation.fromPartial(object.external_docs)
      : null;
    message.example = object.example ?? "";
    return message;
  },
};

function createBaseJSONSchema(): JSONSchema {
  return {
    ref: "",
    title: "",
    description: "",
    default: "",
    read_only: false,
    example: "",
    multiple_of: 0,
    maximum: 0,
    exclusive_maximum: false,
    minimum: 0,
    exclusive_minimum: false,
    max_length: BigInt("0"),
    min_length: BigInt("0"),
    pattern: "",
    max_items: BigInt("0"),
    min_items: BigInt("0"),
    unique_items: false,
    max_properties: BigInt("0"),
    min_properties: BigInt("0"),
    required: [],
    array: [],
    type: [],
    format: "",
    enum: [],
    field_configuration: null,
    extensions: {},
  };
}

export const JSONSchema = {
  encode(message: JSONSchema, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.ref !== "") {
      writer.uint32(26).string(message.ref);
    }
    if (message.title !== "") {
      writer.uint32(42).string(message.title);
    }
    if (message.description !== "") {
      writer.uint32(50).string(message.description);
    }
    if (message.default !== "") {
      writer.uint32(58).string(message.default);
    }
    if (message.read_only !== false) {
      writer.uint32(64).bool(message.read_only);
    }
    if (message.example !== "") {
      writer.uint32(74).string(message.example);
    }
    if (message.multiple_of !== 0) {
      writer.uint32(81).double(message.multiple_of);
    }
    if (message.maximum !== 0) {
      writer.uint32(89).double(message.maximum);
    }
    if (message.exclusive_maximum !== false) {
      writer.uint32(96).bool(message.exclusive_maximum);
    }
    if (message.minimum !== 0) {
      writer.uint32(105).double(message.minimum);
    }
    if (message.exclusive_minimum !== false) {
      writer.uint32(112).bool(message.exclusive_minimum);
    }
    if (message.max_length !== BigInt("0")) {
      if (BigInt.asUintN(64, message.max_length) !== message.max_length) {
        throw new globalThis.Error("value provided for field message.max_length of type uint64 too large");
      }
      writer.uint32(120).uint64(message.max_length.toString());
    }
    if (message.min_length !== BigInt("0")) {
      if (BigInt.asUintN(64, message.min_length) !== message.min_length) {
        throw new globalThis.Error("value provided for field message.min_length of type uint64 too large");
      }
      writer.uint32(128).uint64(message.min_length.toString());
    }
    if (message.pattern !== "") {
      writer.uint32(138).string(message.pattern);
    }
    if (message.max_items !== BigInt("0")) {
      if (BigInt.asUintN(64, message.max_items) !== message.max_items) {
        throw new globalThis.Error("value provided for field message.max_items of type uint64 too large");
      }
      writer.uint32(160).uint64(message.max_items.toString());
    }
    if (message.min_items !== BigInt("0")) {
      if (BigInt.asUintN(64, message.min_items) !== message.min_items) {
        throw new globalThis.Error("value provided for field message.min_items of type uint64 too large");
      }
      writer.uint32(168).uint64(message.min_items.toString());
    }
    if (message.unique_items !== false) {
      writer.uint32(176).bool(message.unique_items);
    }
    if (message.max_properties !== BigInt("0")) {
      if (BigInt.asUintN(64, message.max_properties) !== message.max_properties) {
        throw new globalThis.Error("value provided for field message.max_properties of type uint64 too large");
      }
      writer.uint32(192).uint64(message.max_properties.toString());
    }
    if (message.min_properties !== BigInt("0")) {
      if (BigInt.asUintN(64, message.min_properties) !== message.min_properties) {
        throw new globalThis.Error("value provided for field message.min_properties of type uint64 too large");
      }
      writer.uint32(200).uint64(message.min_properties.toString());
    }
    for (const v of message.required) {
      writer.uint32(210).string(v!);
    }
    for (const v of message.array) {
      writer.uint32(274).string(v!);
    }
    writer.uint32(282).fork();
    for (const v of message.type) {
      writer.int32(jSONSchema_JSONSchemaSimpleTypesToNumber(v));
    }
    writer.ldelim();
    if (message.format !== "") {
      writer.uint32(290).string(message.format);
    }
    for (const v of message.enum) {
      writer.uint32(370).string(v!);
    }
    if (message.field_configuration !== undefined && message.field_configuration !== null) {
      JSONSchema_FieldConfiguration.encode(message.field_configuration, writer.uint32(8010).fork()).ldelim();
    }
    Object.entries(message.extensions).forEach(([key, value]) => {
      if (value !== undefined || value !== null) {
        JSONSchema_ExtensionsEntry.encode({ key: key as any, value }, writer.uint32(386).fork()).ldelim();
      }
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): JSONSchema {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseJSONSchema();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 3:
          if (tag !== 26) {
            break;
          }

          message.ref = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.title = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.description = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.default = reader.string();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.read_only = reader.bool();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.example = reader.string();
          continue;
        case 10:
          if (tag !== 81) {
            break;
          }

          message.multiple_of = reader.double();
          continue;
        case 11:
          if (tag !== 89) {
            break;
          }

          message.maximum = reader.double();
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.exclusive_maximum = reader.bool();
          continue;
        case 13:
          if (tag !== 105) {
            break;
          }

          message.minimum = reader.double();
          continue;
        case 14:
          if (tag !== 112) {
            break;
          }

          message.exclusive_minimum = reader.bool();
          continue;
        case 15:
          if (tag !== 120) {
            break;
          }

          message.max_length = longToBigint(reader.uint64() as Long);
          continue;
        case 16:
          if (tag !== 128) {
            break;
          }

          message.min_length = longToBigint(reader.uint64() as Long);
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }

          message.pattern = reader.string();
          continue;
        case 20:
          if (tag !== 160) {
            break;
          }

          message.max_items = longToBigint(reader.uint64() as Long);
          continue;
        case 21:
          if (tag !== 168) {
            break;
          }

          message.min_items = longToBigint(reader.uint64() as Long);
          continue;
        case 22:
          if (tag !== 176) {
            break;
          }

          message.unique_items = reader.bool();
          continue;
        case 24:
          if (tag !== 192) {
            break;
          }

          message.max_properties = longToBigint(reader.uint64() as Long);
          continue;
        case 25:
          if (tag !== 200) {
            break;
          }

          message.min_properties = longToBigint(reader.uint64() as Long);
          continue;
        case 26:
          if (tag !== 210) {
            break;
          }

          message.required.push(reader.string());
          continue;
        case 34:
          if (tag !== 274) {
            break;
          }

          message.array.push(reader.string());
          continue;
        case 35:
          if (tag === 280) {
            message.type.push(jSONSchema_JSONSchemaSimpleTypesFromJSON(reader.int32()));

            continue;
          }

          if (tag === 282) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.type.push(jSONSchema_JSONSchemaSimpleTypesFromJSON(reader.int32()));
            }

            continue;
          }

          break;
        case 36:
          if (tag !== 290) {
            break;
          }

          message.format = reader.string();
          continue;
        case 46:
          if (tag !== 370) {
            break;
          }

          message.enum.push(reader.string());
          continue;
        case 1001:
          if (tag !== 8010) {
            break;
          }

          message.field_configuration = JSONSchema_FieldConfiguration.decode(reader, reader.uint32());
          continue;
        case 48:
          if (tag !== 386) {
            break;
          }

          const entry48 = JSONSchema_ExtensionsEntry.decode(reader, reader.uint32());
          if (entry48.value !== undefined && entry48.value !== null) {
            message.extensions[entry48.key] = entry48.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<JSONSchema, Uint8Array>
  async *encodeTransform(
    source: AsyncIterable<JSONSchema | JSONSchema[]> | Iterable<JSONSchema | JSONSchema[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [JSONSchema.encode(p).finish()];
        }
      } else {
        yield* [JSONSchema.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, JSONSchema>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<JSONSchema> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [JSONSchema.decode(p)];
        }
      } else {
        yield* [JSONSchema.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): JSONSchema {
    return {
      ref: isSet(object.ref) ? globalThis.String(object.ref) : "",
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      default: isSet(object.default) ? globalThis.String(object.default) : "",
      read_only: isSet(object.read_only) ? globalThis.Boolean(object.read_only) : false,
      example: isSet(object.example) ? globalThis.String(object.example) : "",
      multiple_of: isSet(object.multiple_of) ? globalThis.Number(object.multiple_of) : 0,
      maximum: isSet(object.maximum) ? globalThis.Number(object.maximum) : 0,
      exclusive_maximum: isSet(object.exclusive_maximum) ? globalThis.Boolean(object.exclusive_maximum) : false,
      minimum: isSet(object.minimum) ? globalThis.Number(object.minimum) : 0,
      exclusive_minimum: isSet(object.exclusive_minimum) ? globalThis.Boolean(object.exclusive_minimum) : false,
      max_length: isSet(object.max_length) ? BigInt(object.max_length) : BigInt("0"),
      min_length: isSet(object.min_length) ? BigInt(object.min_length) : BigInt("0"),
      pattern: isSet(object.pattern) ? globalThis.String(object.pattern) : "",
      max_items: isSet(object.max_items) ? BigInt(object.max_items) : BigInt("0"),
      min_items: isSet(object.min_items) ? BigInt(object.min_items) : BigInt("0"),
      unique_items: isSet(object.unique_items) ? globalThis.Boolean(object.unique_items) : false,
      max_properties: isSet(object.max_properties) ? BigInt(object.max_properties) : BigInt("0"),
      min_properties: isSet(object.min_properties) ? BigInt(object.min_properties) : BigInt("0"),
      required: globalThis.Array.isArray(object?.required) ? object.required.map((e: any) => globalThis.String(e)) : [],
      array: globalThis.Array.isArray(object?.array) ? object.array.map((e: any) => globalThis.String(e)) : [],
      type: globalThis.Array.isArray(object?.type)
        ? object.type.map((e: any) => jSONSchema_JSONSchemaSimpleTypesFromJSON(e))
        : [],
      format: isSet(object.format) ? globalThis.String(object.format) : "",
      enum: globalThis.Array.isArray(object?.enum) ? object.enum.map((e: any) => globalThis.String(e)) : [],
      field_configuration: isSet(object.field_configuration)
        ? JSONSchema_FieldConfiguration.fromJSON(object.field_configuration)
        : null,
      extensions: isObject(object.extensions)
        ? Object.entries(object.extensions).reduce<{ [key: string]: any | null }>((acc, [key, value]) => {
          acc[key] = value as any | null;
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: JSONSchema): unknown {
    const obj: any = {};
    if (message.ref !== "") {
      obj.ref = message.ref;
    }
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.default !== "") {
      obj.default = message.default;
    }
    if (message.read_only !== false) {
      obj.read_only = message.read_only;
    }
    if (message.example !== "") {
      obj.example = message.example;
    }
    if (message.multiple_of !== 0) {
      obj.multiple_of = message.multiple_of;
    }
    if (message.maximum !== 0) {
      obj.maximum = message.maximum;
    }
    if (message.exclusive_maximum !== false) {
      obj.exclusive_maximum = message.exclusive_maximum;
    }
    if (message.minimum !== 0) {
      obj.minimum = message.minimum;
    }
    if (message.exclusive_minimum !== false) {
      obj.exclusive_minimum = message.exclusive_minimum;
    }
    if (message.max_length !== BigInt("0")) {
      obj.max_length = message.max_length.toString();
    }
    if (message.min_length !== BigInt("0")) {
      obj.min_length = message.min_length.toString();
    }
    if (message.pattern !== "") {
      obj.pattern = message.pattern;
    }
    if (message.max_items !== BigInt("0")) {
      obj.max_items = message.max_items.toString();
    }
    if (message.min_items !== BigInt("0")) {
      obj.min_items = message.min_items.toString();
    }
    if (message.unique_items !== false) {
      obj.unique_items = message.unique_items;
    }
    if (message.max_properties !== BigInt("0")) {
      obj.max_properties = message.max_properties.toString();
    }
    if (message.min_properties !== BigInt("0")) {
      obj.min_properties = message.min_properties.toString();
    }
    if (message.required?.length) {
      obj.required = message.required;
    }
    if (message.array?.length) {
      obj.array = message.array;
    }
    if (message.type?.length) {
      obj.type = message.type.map((e) => jSONSchema_JSONSchemaSimpleTypesToJSON(e));
    }
    if (message.format !== "") {
      obj.format = message.format;
    }
    if (message.enum?.length) {
      obj.enum = message.enum;
    }
    if (message.field_configuration !== undefined && message.field_configuration !== null) {
      obj.field_configuration = JSONSchema_FieldConfiguration.toJSON(message.field_configuration);
    }
    if (message.extensions) {
      const entries = Object.entries(message.extensions);
      if (entries.length > 0) {
        obj.extensions = {};
        entries.forEach(([k, v]) => {
          obj.extensions[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<JSONSchema>, I>>(base?: I): JSONSchema {
    return JSONSchema.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<JSONSchema>, I>>(object: I): JSONSchema {
    const message = createBaseJSONSchema();
    message.ref = object.ref ?? "";
    message.title = object.title ?? "";
    message.description = object.description ?? "";
    message.default = object.default ?? "";
    message.read_only = object.read_only ?? false;
    message.example = object.example ?? "";
    message.multiple_of = object.multiple_of ?? 0;
    message.maximum = object.maximum ?? 0;
    message.exclusive_maximum = object.exclusive_maximum ?? false;
    message.minimum = object.minimum ?? 0;
    message.exclusive_minimum = object.exclusive_minimum ?? false;
    message.max_length = object.max_length ?? BigInt("0");
    message.min_length = object.min_length ?? BigInt("0");
    message.pattern = object.pattern ?? "";
    message.max_items = object.max_items ?? BigInt("0");
    message.min_items = object.min_items ?? BigInt("0");
    message.unique_items = object.unique_items ?? false;
    message.max_properties = object.max_properties ?? BigInt("0");
    message.min_properties = object.min_properties ?? BigInt("0");
    message.required = object.required?.map((e) => e) || [];
    message.array = object.array?.map((e) => e) || [];
    message.type = object.type?.map((e) => e) || [];
    message.format = object.format ?? "";
    message.enum = object.enum?.map((e) => e) || [];
    message.field_configuration = (object.field_configuration !== undefined && object.field_configuration !== null)
      ? JSONSchema_FieldConfiguration.fromPartial(object.field_configuration)
      : null;
    message.extensions = Object.entries(object.extensions ?? {}).reduce<{ [key: string]: any | null }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = value;
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseJSONSchema_FieldConfiguration(): JSONSchema_FieldConfiguration {
  return { path_param_name: "" };
}

export const JSONSchema_FieldConfiguration = {
  encode(message: JSONSchema_FieldConfiguration, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.path_param_name !== "") {
      writer.uint32(378).string(message.path_param_name);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): JSONSchema_FieldConfiguration {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseJSONSchema_FieldConfiguration();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 47:
          if (tag !== 378) {
            break;
          }

          message.path_param_name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<JSONSchema_FieldConfiguration, Uint8Array>
  async *encodeTransform(
    source:
      | AsyncIterable<JSONSchema_FieldConfiguration | JSONSchema_FieldConfiguration[]>
      | Iterable<JSONSchema_FieldConfiguration | JSONSchema_FieldConfiguration[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [JSONSchema_FieldConfiguration.encode(p).finish()];
        }
      } else {
        yield* [JSONSchema_FieldConfiguration.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, JSONSchema_FieldConfiguration>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<JSONSchema_FieldConfiguration> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [JSONSchema_FieldConfiguration.decode(p)];
        }
      } else {
        yield* [JSONSchema_FieldConfiguration.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): JSONSchema_FieldConfiguration {
    return { path_param_name: isSet(object.path_param_name) ? globalThis.String(object.path_param_name) : "" };
  },

  toJSON(message: JSONSchema_FieldConfiguration): unknown {
    const obj: any = {};
    if (message.path_param_name !== "") {
      obj.path_param_name = message.path_param_name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<JSONSchema_FieldConfiguration>, I>>(base?: I): JSONSchema_FieldConfiguration {
    return JSONSchema_FieldConfiguration.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<JSONSchema_FieldConfiguration>, I>>(
    object: I,
  ): JSONSchema_FieldConfiguration {
    const message = createBaseJSONSchema_FieldConfiguration();
    message.path_param_name = object.path_param_name ?? "";
    return message;
  },
};

function createBaseJSONSchema_ExtensionsEntry(): JSONSchema_ExtensionsEntry {
  return { key: "", value: null };
}

export const JSONSchema_ExtensionsEntry = {
  encode(message: JSONSchema_ExtensionsEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined && message.value !== null) {
      Value.encode(Value.wrap(message.value), writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): JSONSchema_ExtensionsEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseJSONSchema_ExtensionsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = Value.unwrap(Value.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<JSONSchema_ExtensionsEntry, Uint8Array>
  async *encodeTransform(
    source:
      | AsyncIterable<JSONSchema_ExtensionsEntry | JSONSchema_ExtensionsEntry[]>
      | Iterable<JSONSchema_ExtensionsEntry | JSONSchema_ExtensionsEntry[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [JSONSchema_ExtensionsEntry.encode(p).finish()];
        }
      } else {
        yield* [JSONSchema_ExtensionsEntry.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, JSONSchema_ExtensionsEntry>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<JSONSchema_ExtensionsEntry> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [JSONSchema_ExtensionsEntry.decode(p)];
        }
      } else {
        yield* [JSONSchema_ExtensionsEntry.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): JSONSchema_ExtensionsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object?.value) ? object.value : null,
    };
  },

  toJSON(message: JSONSchema_ExtensionsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined && message.value !== null) {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<JSONSchema_ExtensionsEntry>, I>>(base?: I): JSONSchema_ExtensionsEntry {
    return JSONSchema_ExtensionsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<JSONSchema_ExtensionsEntry>, I>>(object: I): JSONSchema_ExtensionsEntry {
    const message = createBaseJSONSchema_ExtensionsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? null;
    return message;
  },
};

function createBaseTag(): Tag {
  return { name: "", description: "", external_docs: null, extensions: {} };
}

export const Tag = {
  encode(message: Tag, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    if (message.external_docs !== undefined && message.external_docs !== null) {
      ExternalDocumentation.encode(message.external_docs, writer.uint32(26).fork()).ldelim();
    }
    Object.entries(message.extensions).forEach(([key, value]) => {
      if (value !== undefined || value !== null) {
        Tag_ExtensionsEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).ldelim();
      }
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Tag {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTag();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.external_docs = ExternalDocumentation.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          const entry4 = Tag_ExtensionsEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined && entry4.value !== null) {
            message.extensions[entry4.key] = entry4.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<Tag, Uint8Array>
  async *encodeTransform(source: AsyncIterable<Tag | Tag[]> | Iterable<Tag | Tag[]>): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [Tag.encode(p).finish()];
        }
      } else {
        yield* [Tag.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, Tag>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<Tag> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [Tag.decode(p)];
        }
      } else {
        yield* [Tag.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): Tag {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      external_docs: isSet(object.external_docs) ? ExternalDocumentation.fromJSON(object.external_docs) : null,
      extensions: isObject(object.extensions)
        ? Object.entries(object.extensions).reduce<{ [key: string]: any | null }>((acc, [key, value]) => {
          acc[key] = value as any | null;
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: Tag): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.external_docs !== undefined && message.external_docs !== null) {
      obj.external_docs = ExternalDocumentation.toJSON(message.external_docs);
    }
    if (message.extensions) {
      const entries = Object.entries(message.extensions);
      if (entries.length > 0) {
        obj.extensions = {};
        entries.forEach(([k, v]) => {
          obj.extensions[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Tag>, I>>(base?: I): Tag {
    return Tag.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Tag>, I>>(object: I): Tag {
    const message = createBaseTag();
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    message.external_docs = (object.external_docs !== undefined && object.external_docs !== null)
      ? ExternalDocumentation.fromPartial(object.external_docs)
      : null;
    message.extensions = Object.entries(object.extensions ?? {}).reduce<{ [key: string]: any | null }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = value;
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseTag_ExtensionsEntry(): Tag_ExtensionsEntry {
  return { key: "", value: null };
}

export const Tag_ExtensionsEntry = {
  encode(message: Tag_ExtensionsEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined && message.value !== null) {
      Value.encode(Value.wrap(message.value), writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Tag_ExtensionsEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTag_ExtensionsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = Value.unwrap(Value.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<Tag_ExtensionsEntry, Uint8Array>
  async *encodeTransform(
    source:
      | AsyncIterable<Tag_ExtensionsEntry | Tag_ExtensionsEntry[]>
      | Iterable<Tag_ExtensionsEntry | Tag_ExtensionsEntry[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [Tag_ExtensionsEntry.encode(p).finish()];
        }
      } else {
        yield* [Tag_ExtensionsEntry.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, Tag_ExtensionsEntry>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<Tag_ExtensionsEntry> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [Tag_ExtensionsEntry.decode(p)];
        }
      } else {
        yield* [Tag_ExtensionsEntry.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): Tag_ExtensionsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object?.value) ? object.value : null,
    };
  },

  toJSON(message: Tag_ExtensionsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined && message.value !== null) {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Tag_ExtensionsEntry>, I>>(base?: I): Tag_ExtensionsEntry {
    return Tag_ExtensionsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Tag_ExtensionsEntry>, I>>(object: I): Tag_ExtensionsEntry {
    const message = createBaseTag_ExtensionsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? null;
    return message;
  },
};

function createBaseSecurityDefinitions(): SecurityDefinitions {
  return { security: {} };
}

export const SecurityDefinitions = {
  encode(message: SecurityDefinitions, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    Object.entries(message.security).forEach(([key, value]) => {
      SecurityDefinitions_SecurityEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SecurityDefinitions {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSecurityDefinitions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          const entry1 = SecurityDefinitions_SecurityEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined && entry1.value !== null) {
            message.security[entry1.key] = entry1.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<SecurityDefinitions, Uint8Array>
  async *encodeTransform(
    source:
      | AsyncIterable<SecurityDefinitions | SecurityDefinitions[]>
      | Iterable<SecurityDefinitions | SecurityDefinitions[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [SecurityDefinitions.encode(p).finish()];
        }
      } else {
        yield* [SecurityDefinitions.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, SecurityDefinitions>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<SecurityDefinitions> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [SecurityDefinitions.decode(p)];
        }
      } else {
        yield* [SecurityDefinitions.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): SecurityDefinitions {
    return {
      security: isObject(object.security)
        ? Object.entries(object.security).reduce<{ [key: string]: SecurityScheme }>((acc, [key, value]) => {
          acc[key] = SecurityScheme.fromJSON(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: SecurityDefinitions): unknown {
    const obj: any = {};
    if (message.security) {
      const entries = Object.entries(message.security);
      if (entries.length > 0) {
        obj.security = {};
        entries.forEach(([k, v]) => {
          obj.security[k] = SecurityScheme.toJSON(v);
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SecurityDefinitions>, I>>(base?: I): SecurityDefinitions {
    return SecurityDefinitions.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SecurityDefinitions>, I>>(object: I): SecurityDefinitions {
    const message = createBaseSecurityDefinitions();
    message.security = Object.entries(object.security ?? {}).reduce<{ [key: string]: SecurityScheme }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = SecurityScheme.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseSecurityDefinitions_SecurityEntry(): SecurityDefinitions_SecurityEntry {
  return { key: "", value: null };
}

export const SecurityDefinitions_SecurityEntry = {
  encode(message: SecurityDefinitions_SecurityEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined && message.value !== null) {
      SecurityScheme.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SecurityDefinitions_SecurityEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSecurityDefinitions_SecurityEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = SecurityScheme.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<SecurityDefinitions_SecurityEntry, Uint8Array>
  async *encodeTransform(
    source:
      | AsyncIterable<SecurityDefinitions_SecurityEntry | SecurityDefinitions_SecurityEntry[]>
      | Iterable<SecurityDefinitions_SecurityEntry | SecurityDefinitions_SecurityEntry[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [SecurityDefinitions_SecurityEntry.encode(p).finish()];
        }
      } else {
        yield* [SecurityDefinitions_SecurityEntry.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, SecurityDefinitions_SecurityEntry>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<SecurityDefinitions_SecurityEntry> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [SecurityDefinitions_SecurityEntry.decode(p)];
        }
      } else {
        yield* [SecurityDefinitions_SecurityEntry.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): SecurityDefinitions_SecurityEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? SecurityScheme.fromJSON(object.value) : null,
    };
  },

  toJSON(message: SecurityDefinitions_SecurityEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined && message.value !== null) {
      obj.value = SecurityScheme.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SecurityDefinitions_SecurityEntry>, I>>(
    base?: I,
  ): SecurityDefinitions_SecurityEntry {
    return SecurityDefinitions_SecurityEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SecurityDefinitions_SecurityEntry>, I>>(
    object: I,
  ): SecurityDefinitions_SecurityEntry {
    const message = createBaseSecurityDefinitions_SecurityEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? SecurityScheme.fromPartial(object.value)
      : null;
    return message;
  },
};

function createBaseSecurityScheme(): SecurityScheme {
  return {
    type: SecurityScheme_Type.INVALID,
    description: "",
    name: "",
    in: SecurityScheme_In.INVALID,
    flow: SecurityScheme_Flow.INVALID,
    authorization_url: "",
    token_url: "",
    scopes: null,
    extensions: {},
  };
}

export const SecurityScheme = {
  encode(message: SecurityScheme, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.type !== SecurityScheme_Type.INVALID) {
      writer.uint32(8).int32(securityScheme_TypeToNumber(message.type));
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.in !== SecurityScheme_In.INVALID) {
      writer.uint32(32).int32(securityScheme_InToNumber(message.in));
    }
    if (message.flow !== SecurityScheme_Flow.INVALID) {
      writer.uint32(40).int32(securityScheme_FlowToNumber(message.flow));
    }
    if (message.authorization_url !== "") {
      writer.uint32(50).string(message.authorization_url);
    }
    if (message.token_url !== "") {
      writer.uint32(58).string(message.token_url);
    }
    if (message.scopes !== undefined && message.scopes !== null) {
      Scopes.encode(message.scopes, writer.uint32(66).fork()).ldelim();
    }
    Object.entries(message.extensions).forEach(([key, value]) => {
      if (value !== undefined || value !== null) {
        SecurityScheme_ExtensionsEntry.encode({ key: key as any, value }, writer.uint32(74).fork()).ldelim();
      }
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SecurityScheme {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSecurityScheme();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.type = securityScheme_TypeFromJSON(reader.int32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.in = securityScheme_InFromJSON(reader.int32());
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.flow = securityScheme_FlowFromJSON(reader.int32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.authorization_url = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.token_url = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.scopes = Scopes.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          const entry9 = SecurityScheme_ExtensionsEntry.decode(reader, reader.uint32());
          if (entry9.value !== undefined && entry9.value !== null) {
            message.extensions[entry9.key] = entry9.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<SecurityScheme, Uint8Array>
  async *encodeTransform(
    source: AsyncIterable<SecurityScheme | SecurityScheme[]> | Iterable<SecurityScheme | SecurityScheme[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [SecurityScheme.encode(p).finish()];
        }
      } else {
        yield* [SecurityScheme.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, SecurityScheme>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<SecurityScheme> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [SecurityScheme.decode(p)];
        }
      } else {
        yield* [SecurityScheme.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): SecurityScheme {
    return {
      type: isSet(object.type) ? securityScheme_TypeFromJSON(object.type) : SecurityScheme_Type.INVALID,
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      in: isSet(object.in) ? securityScheme_InFromJSON(object.in) : SecurityScheme_In.INVALID,
      flow: isSet(object.flow) ? securityScheme_FlowFromJSON(object.flow) : SecurityScheme_Flow.INVALID,
      authorization_url: isSet(object.authorization_url) ? globalThis.String(object.authorization_url) : "",
      token_url: isSet(object.token_url) ? globalThis.String(object.token_url) : "",
      scopes: isSet(object.scopes) ? Scopes.fromJSON(object.scopes) : null,
      extensions: isObject(object.extensions)
        ? Object.entries(object.extensions).reduce<{ [key: string]: any | null }>((acc, [key, value]) => {
          acc[key] = value as any | null;
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: SecurityScheme): unknown {
    const obj: any = {};
    if (message.type !== SecurityScheme_Type.INVALID) {
      obj.type = securityScheme_TypeToJSON(message.type);
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.in !== SecurityScheme_In.INVALID) {
      obj.in = securityScheme_InToJSON(message.in);
    }
    if (message.flow !== SecurityScheme_Flow.INVALID) {
      obj.flow = securityScheme_FlowToJSON(message.flow);
    }
    if (message.authorization_url !== "") {
      obj.authorization_url = message.authorization_url;
    }
    if (message.token_url !== "") {
      obj.token_url = message.token_url;
    }
    if (message.scopes !== undefined && message.scopes !== null) {
      obj.scopes = Scopes.toJSON(message.scopes);
    }
    if (message.extensions) {
      const entries = Object.entries(message.extensions);
      if (entries.length > 0) {
        obj.extensions = {};
        entries.forEach(([k, v]) => {
          obj.extensions[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SecurityScheme>, I>>(base?: I): SecurityScheme {
    return SecurityScheme.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SecurityScheme>, I>>(object: I): SecurityScheme {
    const message = createBaseSecurityScheme();
    message.type = object.type ?? SecurityScheme_Type.INVALID;
    message.description = object.description ?? "";
    message.name = object.name ?? "";
    message.in = object.in ?? SecurityScheme_In.INVALID;
    message.flow = object.flow ?? SecurityScheme_Flow.INVALID;
    message.authorization_url = object.authorization_url ?? "";
    message.token_url = object.token_url ?? "";
    message.scopes = (object.scopes !== undefined && object.scopes !== null) ? Scopes.fromPartial(object.scopes) : null;
    message.extensions = Object.entries(object.extensions ?? {}).reduce<{ [key: string]: any | null }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = value;
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseSecurityScheme_ExtensionsEntry(): SecurityScheme_ExtensionsEntry {
  return { key: "", value: null };
}

export const SecurityScheme_ExtensionsEntry = {
  encode(message: SecurityScheme_ExtensionsEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined && message.value !== null) {
      Value.encode(Value.wrap(message.value), writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SecurityScheme_ExtensionsEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSecurityScheme_ExtensionsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = Value.unwrap(Value.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<SecurityScheme_ExtensionsEntry, Uint8Array>
  async *encodeTransform(
    source:
      | AsyncIterable<SecurityScheme_ExtensionsEntry | SecurityScheme_ExtensionsEntry[]>
      | Iterable<SecurityScheme_ExtensionsEntry | SecurityScheme_ExtensionsEntry[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [SecurityScheme_ExtensionsEntry.encode(p).finish()];
        }
      } else {
        yield* [SecurityScheme_ExtensionsEntry.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, SecurityScheme_ExtensionsEntry>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<SecurityScheme_ExtensionsEntry> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [SecurityScheme_ExtensionsEntry.decode(p)];
        }
      } else {
        yield* [SecurityScheme_ExtensionsEntry.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): SecurityScheme_ExtensionsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object?.value) ? object.value : null,
    };
  },

  toJSON(message: SecurityScheme_ExtensionsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined && message.value !== null) {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SecurityScheme_ExtensionsEntry>, I>>(base?: I): SecurityScheme_ExtensionsEntry {
    return SecurityScheme_ExtensionsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SecurityScheme_ExtensionsEntry>, I>>(
    object: I,
  ): SecurityScheme_ExtensionsEntry {
    const message = createBaseSecurityScheme_ExtensionsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? null;
    return message;
  },
};

function createBaseSecurityRequirement(): SecurityRequirement {
  return { security_requirement: {} };
}

export const SecurityRequirement = {
  encode(message: SecurityRequirement, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    Object.entries(message.security_requirement).forEach(([key, value]) => {
      SecurityRequirement_SecurityRequirementEntry.encode({ key: key as any, value }, writer.uint32(10).fork())
        .ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SecurityRequirement {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSecurityRequirement();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          const entry1 = SecurityRequirement_SecurityRequirementEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined && entry1.value !== null) {
            message.security_requirement[entry1.key] = entry1.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<SecurityRequirement, Uint8Array>
  async *encodeTransform(
    source:
      | AsyncIterable<SecurityRequirement | SecurityRequirement[]>
      | Iterable<SecurityRequirement | SecurityRequirement[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [SecurityRequirement.encode(p).finish()];
        }
      } else {
        yield* [SecurityRequirement.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, SecurityRequirement>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<SecurityRequirement> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [SecurityRequirement.decode(p)];
        }
      } else {
        yield* [SecurityRequirement.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): SecurityRequirement {
    return {
      security_requirement: isObject(object.security_requirement)
        ? Object.entries(object.security_requirement).reduce<
          { [key: string]: SecurityRequirement_SecurityRequirementValue }
        >((acc, [key, value]) => {
          acc[key] = SecurityRequirement_SecurityRequirementValue.fromJSON(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: SecurityRequirement): unknown {
    const obj: any = {};
    if (message.security_requirement) {
      const entries = Object.entries(message.security_requirement);
      if (entries.length > 0) {
        obj.security_requirement = {};
        entries.forEach(([k, v]) => {
          obj.security_requirement[k] = SecurityRequirement_SecurityRequirementValue.toJSON(v);
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SecurityRequirement>, I>>(base?: I): SecurityRequirement {
    return SecurityRequirement.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SecurityRequirement>, I>>(object: I): SecurityRequirement {
    const message = createBaseSecurityRequirement();
    message.security_requirement = Object.entries(object.security_requirement ?? {}).reduce<
      { [key: string]: SecurityRequirement_SecurityRequirementValue }
    >((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = SecurityRequirement_SecurityRequirementValue.fromPartial(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseSecurityRequirement_SecurityRequirementValue(): SecurityRequirement_SecurityRequirementValue {
  return { scope: [] };
}

export const SecurityRequirement_SecurityRequirementValue = {
  encode(message: SecurityRequirement_SecurityRequirementValue, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.scope) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SecurityRequirement_SecurityRequirementValue {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSecurityRequirement_SecurityRequirementValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.scope.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<SecurityRequirement_SecurityRequirementValue, Uint8Array>
  async *encodeTransform(
    source:
      | AsyncIterable<SecurityRequirement_SecurityRequirementValue | SecurityRequirement_SecurityRequirementValue[]>
      | Iterable<SecurityRequirement_SecurityRequirementValue | SecurityRequirement_SecurityRequirementValue[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [SecurityRequirement_SecurityRequirementValue.encode(p).finish()];
        }
      } else {
        yield* [SecurityRequirement_SecurityRequirementValue.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, SecurityRequirement_SecurityRequirementValue>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<SecurityRequirement_SecurityRequirementValue> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [SecurityRequirement_SecurityRequirementValue.decode(p)];
        }
      } else {
        yield* [SecurityRequirement_SecurityRequirementValue.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): SecurityRequirement_SecurityRequirementValue {
    return { scope: globalThis.Array.isArray(object?.scope) ? object.scope.map((e: any) => globalThis.String(e)) : [] };
  },

  toJSON(message: SecurityRequirement_SecurityRequirementValue): unknown {
    const obj: any = {};
    if (message.scope?.length) {
      obj.scope = message.scope;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SecurityRequirement_SecurityRequirementValue>, I>>(
    base?: I,
  ): SecurityRequirement_SecurityRequirementValue {
    return SecurityRequirement_SecurityRequirementValue.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SecurityRequirement_SecurityRequirementValue>, I>>(
    object: I,
  ): SecurityRequirement_SecurityRequirementValue {
    const message = createBaseSecurityRequirement_SecurityRequirementValue();
    message.scope = object.scope?.map((e) => e) || [];
    return message;
  },
};

function createBaseSecurityRequirement_SecurityRequirementEntry(): SecurityRequirement_SecurityRequirementEntry {
  return { key: "", value: null };
}

export const SecurityRequirement_SecurityRequirementEntry = {
  encode(message: SecurityRequirement_SecurityRequirementEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined && message.value !== null) {
      SecurityRequirement_SecurityRequirementValue.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SecurityRequirement_SecurityRequirementEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSecurityRequirement_SecurityRequirementEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = SecurityRequirement_SecurityRequirementValue.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<SecurityRequirement_SecurityRequirementEntry, Uint8Array>
  async *encodeTransform(
    source:
      | AsyncIterable<SecurityRequirement_SecurityRequirementEntry | SecurityRequirement_SecurityRequirementEntry[]>
      | Iterable<SecurityRequirement_SecurityRequirementEntry | SecurityRequirement_SecurityRequirementEntry[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [SecurityRequirement_SecurityRequirementEntry.encode(p).finish()];
        }
      } else {
        yield* [SecurityRequirement_SecurityRequirementEntry.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, SecurityRequirement_SecurityRequirementEntry>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<SecurityRequirement_SecurityRequirementEntry> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [SecurityRequirement_SecurityRequirementEntry.decode(p)];
        }
      } else {
        yield* [SecurityRequirement_SecurityRequirementEntry.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): SecurityRequirement_SecurityRequirementEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? SecurityRequirement_SecurityRequirementValue.fromJSON(object.value) : null,
    };
  },

  toJSON(message: SecurityRequirement_SecurityRequirementEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined && message.value !== null) {
      obj.value = SecurityRequirement_SecurityRequirementValue.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SecurityRequirement_SecurityRequirementEntry>, I>>(
    base?: I,
  ): SecurityRequirement_SecurityRequirementEntry {
    return SecurityRequirement_SecurityRequirementEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SecurityRequirement_SecurityRequirementEntry>, I>>(
    object: I,
  ): SecurityRequirement_SecurityRequirementEntry {
    const message = createBaseSecurityRequirement_SecurityRequirementEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? SecurityRequirement_SecurityRequirementValue.fromPartial(object.value)
      : null;
    return message;
  },
};

function createBaseScopes(): Scopes {
  return { scope: {} };
}

export const Scopes = {
  encode(message: Scopes, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    Object.entries(message.scope).forEach(([key, value]) => {
      Scopes_ScopeEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Scopes {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseScopes();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          const entry1 = Scopes_ScopeEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined && entry1.value !== null) {
            message.scope[entry1.key] = entry1.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<Scopes, Uint8Array>
  async *encodeTransform(
    source: AsyncIterable<Scopes | Scopes[]> | Iterable<Scopes | Scopes[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [Scopes.encode(p).finish()];
        }
      } else {
        yield* [Scopes.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, Scopes>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<Scopes> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [Scopes.decode(p)];
        }
      } else {
        yield* [Scopes.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): Scopes {
    return {
      scope: isObject(object.scope)
        ? Object.entries(object.scope).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: Scopes): unknown {
    const obj: any = {};
    if (message.scope) {
      const entries = Object.entries(message.scope);
      if (entries.length > 0) {
        obj.scope = {};
        entries.forEach(([k, v]) => {
          obj.scope[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Scopes>, I>>(base?: I): Scopes {
    return Scopes.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Scopes>, I>>(object: I): Scopes {
    const message = createBaseScopes();
    message.scope = Object.entries(object.scope ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseScopes_ScopeEntry(): Scopes_ScopeEntry {
  return { key: "", value: "" };
}

export const Scopes_ScopeEntry = {
  encode(message: Scopes_ScopeEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Scopes_ScopeEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseScopes_ScopeEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<Scopes_ScopeEntry, Uint8Array>
  async *encodeTransform(
    source: AsyncIterable<Scopes_ScopeEntry | Scopes_ScopeEntry[]> | Iterable<Scopes_ScopeEntry | Scopes_ScopeEntry[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [Scopes_ScopeEntry.encode(p).finish()];
        }
      } else {
        yield* [Scopes_ScopeEntry.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, Scopes_ScopeEntry>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<Scopes_ScopeEntry> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [Scopes_ScopeEntry.decode(p)];
        }
      } else {
        yield* [Scopes_ScopeEntry.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): Scopes_ScopeEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Scopes_ScopeEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Scopes_ScopeEntry>, I>>(base?: I): Scopes_ScopeEntry {
    return Scopes_ScopeEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Scopes_ScopeEntry>, I>>(object: I): Scopes_ScopeEntry {
    const message = createBaseScopes_ScopeEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

export interface DataLoaderOptions {
  cache?: boolean;
}

export interface DataLoaders {
  rpcDataLoaderOptions?: DataLoaderOptions;
  getDataLoader<T>(identifier: string, constructorFn: () => T): T;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | bigint | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToBigint(long: Long) {
  return BigInt(long.toString());
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
