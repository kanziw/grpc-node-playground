// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.178.0
//   protoc               unknown
// source: google/rpc/error_details.proto

/* eslint-disable */
import _m0 from "protobufjs/minimal.js";
import { Duration } from "../protobuf/duration.js";

export const protobufPackage = "google.rpc";

/**
 * Describes the cause of the error with structured details.
 *
 * Example of an error when contacting the "pubsub.googleapis.com" API when it
 * is not enabled:
 *
 *     { "reason": "API_DISABLED"
 *       "domain": "googleapis.com"
 *       "metadata": {
 *         "resource": "projects/123",
 *         "service": "pubsub.googleapis.com"
 *       }
 *     }
 *
 * This response indicates that the pubsub.googleapis.com API is not enabled.
 *
 * Example of an error that is returned when attempting to create a Spanner
 * instance in a region that is out of stock:
 *
 *     { "reason": "STOCKOUT"
 *       "domain": "spanner.googleapis.com",
 *       "metadata": {
 *         "availableRegions": "us-central1,us-east2"
 *       }
 *     }
 */
export interface ErrorInfo {
  /**
   * The reason of the error. This is a constant value that identifies the
   * proximate cause of the error. Error reasons are unique within a particular
   * domain of errors. This should be at most 63 characters and match a
   * regular expression of `[A-Z][A-Z0-9_]+[A-Z0-9]`, which represents
   * UPPER_SNAKE_CASE.
   */
  reason: string;
  /**
   * The logical grouping to which the "reason" belongs. The error domain
   * is typically the registered service name of the tool or product that
   * generates the error. Example: "pubsub.googleapis.com". If the error is
   * generated by some common infrastructure, the error domain must be a
   * globally unique value that identifies the infrastructure. For Google API
   * infrastructure, the error domain is "googleapis.com".
   */
  domain: string;
  /**
   * Additional structured details about this error.
   *
   * Keys should match /[a-zA-Z0-9-_]/ and be limited to 64 characters in
   * length. When identifying the current value of an exceeded limit, the units
   * should be contained in the key, not the value.  For example, rather than
   * {"instanceLimit": "100/request"}, should be returned as,
   * {"instanceLimitPerRequest": "100"}, if the client exceeds the number of
   * instances that can be created in a single (batch) request.
   */
  metadata: { [key: string]: string };
}

export interface ErrorInfo_MetadataEntry {
  key: string;
  value: string;
}

/**
 * Describes when the clients can retry a failed request. Clients could ignore
 * the recommendation here or retry when this information is missing from error
 * responses.
 *
 * It's always recommended that clients should use exponential backoff when
 * retrying.
 *
 * Clients should wait until `retry_delay` amount of time has passed since
 * receiving the error response before retrying.  If retrying requests also
 * fail, clients should use an exponential backoff scheme to gradually increase
 * the delay between retries based on `retry_delay`, until either a maximum
 * number of retries have been reached or a maximum retry delay cap has been
 * reached.
 */
export interface RetryInfo {
  /** Clients should wait at least this long between retrying the same request. */
  retry_delay?: Duration | null;
}

/** Describes additional debugging info. */
export interface DebugInfo {
  /** The stack trace entries indicating where the error occurred. */
  stack_entries: string[];
  /** Additional debugging information provided by the server. */
  detail: string;
}

/**
 * Describes how a quota check failed.
 *
 * For example if a daily limit was exceeded for the calling project,
 * a service could respond with a QuotaFailure detail containing the project
 * id and the description of the quota limit that was exceeded.  If the
 * calling project hasn't enabled the service in the developer console, then
 * a service could respond with the project id and set `service_disabled`
 * to true.
 *
 * Also see RetryInfo and Help types for other details about handling a
 * quota failure.
 */
export interface QuotaFailure {
  /** Describes all quota violations. */
  violations: QuotaFailure_Violation[];
}

/**
 * A message type used to describe a single quota violation.  For example, a
 * daily quota or a custom quota that was exceeded.
 */
export interface QuotaFailure_Violation {
  /**
   * The subject on which the quota check failed.
   * For example, "clientip:<ip address of client>" or "project:<Google
   * developer project id>".
   */
  subject: string;
  /**
   * A description of how the quota check failed. Clients can use this
   * description to find more about the quota configuration in the service's
   * public documentation, or find the relevant quota limit to adjust through
   * developer console.
   *
   * For example: "Service disabled" or "Daily Limit for read operations
   * exceeded".
   */
  description: string;
}

/**
 * Describes what preconditions have failed.
 *
 * For example, if an RPC failed because it required the Terms of Service to be
 * acknowledged, it could list the terms of service violation in the
 * PreconditionFailure message.
 */
export interface PreconditionFailure {
  /** Describes all precondition violations. */
  violations: PreconditionFailure_Violation[];
}

/** A message type used to describe a single precondition failure. */
export interface PreconditionFailure_Violation {
  /**
   * The type of PreconditionFailure. We recommend using a service-specific
   * enum type to define the supported precondition violation subjects. For
   * example, "TOS" for "Terms of Service violation".
   */
  type: string;
  /**
   * The subject, relative to the type, that failed.
   * For example, "google.com/cloud" relative to the "TOS" type would indicate
   * which terms of service is being referenced.
   */
  subject: string;
  /**
   * A description of how the precondition failed. Developers can use this
   * description to understand how to fix the failure.
   *
   * For example: "Terms of service not accepted".
   */
  description: string;
}

/**
 * Describes violations in a client request. This error type focuses on the
 * syntactic aspects of the request.
 */
export interface BadRequest {
  /** Describes all violations in a client request. */
  field_violations: BadRequest_FieldViolation[];
}

/** A message type used to describe a single bad request field. */
export interface BadRequest_FieldViolation {
  /**
   * A path that leads to a field in the request body. The value will be a
   * sequence of dot-separated identifiers that identify a protocol buffer
   * field.
   *
   * Consider the following:
   *
   *     message CreateContactRequest {
   *       message EmailAddress {
   *         enum Type {
   *           TYPE_UNSPECIFIED = 0;
   *           HOME = 1;
   *           WORK = 2;
   *         }
   *
   *         optional string email = 1;
   *         repeated EmailType type = 2;
   *       }
   *
   *       string full_name = 1;
   *       repeated EmailAddress email_addresses = 2;
   *     }
   *
   * In this example, in proto `field` could take one of the following values:
   *
   * * `full_name` for a violation in the `full_name` value
   * * `email_addresses[1].email` for a violation in the `email` field of the
   *   first `email_addresses` message
   * * `email_addresses[3].type[2]` for a violation in the second `type`
   *   value in the third `email_addresses` message.
   *
   * In JSON, the same values are represented as:
   *
   * * `fullName` for a violation in the `fullName` value
   * * `emailAddresses[1].email` for a violation in the `email` field of the
   *   first `emailAddresses` message
   * * `emailAddresses[3].type[2]` for a violation in the second `type`
   *   value in the third `emailAddresses` message.
   */
  field: string;
  /** A description of why the request element is bad. */
  description: string;
}

/**
 * Contains metadata about the request that clients can attach when filing a bug
 * or providing other forms of feedback.
 */
export interface RequestInfo {
  /**
   * An opaque string that should only be interpreted by the service generating
   * it. For example, it can be used to identify requests in the service's logs.
   */
  request_id: string;
  /**
   * Any data that was used to serve this request. For example, an encrypted
   * stack trace that can be sent back to the service provider for debugging.
   */
  serving_data: string;
}

/** Describes the resource that is being accessed. */
export interface ResourceInfo {
  /**
   * A name for the type of resource being accessed, e.g. "sql table",
   * "cloud storage bucket", "file", "Google calendar"; or the type URL
   * of the resource: e.g. "type.googleapis.com/google.pubsub.v1.Topic".
   */
  resource_type: string;
  /**
   * The name of the resource being accessed.  For example, a shared calendar
   * name: "example.com_4fghdhgsrgh@group.calendar.google.com", if the current
   * error is
   * [google.rpc.Code.PERMISSION_DENIED][google.rpc.Code.PERMISSION_DENIED].
   */
  resource_name: string;
  /**
   * The owner of the resource (optional).
   * For example, "user:<owner email>" or "project:<Google developer project
   * id>".
   */
  owner: string;
  /**
   * Describes what error is encountered when accessing this resource.
   * For example, updating a cloud project may require the `writer` permission
   * on the developer console project.
   */
  description: string;
}

/**
 * Provides links to documentation or for performing an out of band action.
 *
 * For example, if a quota check failed with an error indicating the calling
 * project hasn't enabled the accessed service, this can contain a URL pointing
 * directly to the right place in the developer console to flip the bit.
 */
export interface Help {
  /** URL(s) pointing to additional information on handling the current error. */
  links: Help_Link[];
}

/** Describes a URL link. */
export interface Help_Link {
  /** Describes what the link offers. */
  description: string;
  /** The URL of the link. */
  url: string;
}

/**
 * Provides a localized error message that is safe to return to the user
 * which can be attached to an RPC error.
 */
export interface LocalizedMessage {
  /**
   * The locale used following the specification defined at
   * https://www.rfc-editor.org/rfc/bcp/bcp47.txt.
   * Examples are: "en-US", "fr-CH", "es-MX"
   */
  locale: string;
  /** The localized error message in the above locale. */
  message: string;
}

function createBaseErrorInfo(): ErrorInfo {
  return { reason: "", domain: "", metadata: {} };
}

export const ErrorInfo = {
  encode(message: ErrorInfo, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.reason !== "") {
      writer.uint32(10).string(message.reason);
    }
    if (message.domain !== "") {
      writer.uint32(18).string(message.domain);
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      ErrorInfo_MetadataEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ErrorInfo {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseErrorInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.reason = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.domain = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          const entry3 = ErrorInfo_MetadataEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined && entry3.value !== null) {
            message.metadata[entry3.key] = entry3.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<ErrorInfo, Uint8Array>
  async *encodeTransform(
    source: AsyncIterable<ErrorInfo | ErrorInfo[]> | Iterable<ErrorInfo | ErrorInfo[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [ErrorInfo.encode(p).finish()];
        }
      } else {
        yield* [ErrorInfo.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, ErrorInfo>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<ErrorInfo> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [ErrorInfo.decode(p)];
        }
      } else {
        yield* [ErrorInfo.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): ErrorInfo {
    return {
      reason: isSet(object.reason) ? globalThis.String(object.reason) : "",
      domain: isSet(object.domain) ? globalThis.String(object.domain) : "",
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: ErrorInfo): unknown {
    const obj: any = {};
    if (message.reason !== "") {
      obj.reason = message.reason;
    }
    if (message.domain !== "") {
      obj.domain = message.domain;
    }
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ErrorInfo>, I>>(base?: I): ErrorInfo {
    return ErrorInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ErrorInfo>, I>>(object: I): ErrorInfo {
    const message = createBaseErrorInfo();
    message.reason = object.reason ?? "";
    message.domain = object.domain ?? "";
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseErrorInfo_MetadataEntry(): ErrorInfo_MetadataEntry {
  return { key: "", value: "" };
}

export const ErrorInfo_MetadataEntry = {
  encode(message: ErrorInfo_MetadataEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ErrorInfo_MetadataEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseErrorInfo_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<ErrorInfo_MetadataEntry, Uint8Array>
  async *encodeTransform(
    source:
      | AsyncIterable<ErrorInfo_MetadataEntry | ErrorInfo_MetadataEntry[]>
      | Iterable<ErrorInfo_MetadataEntry | ErrorInfo_MetadataEntry[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [ErrorInfo_MetadataEntry.encode(p).finish()];
        }
      } else {
        yield* [ErrorInfo_MetadataEntry.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, ErrorInfo_MetadataEntry>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<ErrorInfo_MetadataEntry> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [ErrorInfo_MetadataEntry.decode(p)];
        }
      } else {
        yield* [ErrorInfo_MetadataEntry.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): ErrorInfo_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: ErrorInfo_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ErrorInfo_MetadataEntry>, I>>(base?: I): ErrorInfo_MetadataEntry {
    return ErrorInfo_MetadataEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ErrorInfo_MetadataEntry>, I>>(object: I): ErrorInfo_MetadataEntry {
    const message = createBaseErrorInfo_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseRetryInfo(): RetryInfo {
  return { retry_delay: null };
}

export const RetryInfo = {
  encode(message: RetryInfo, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.retry_delay !== undefined && message.retry_delay !== null) {
      Duration.encode(message.retry_delay, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RetryInfo {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRetryInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.retry_delay = Duration.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<RetryInfo, Uint8Array>
  async *encodeTransform(
    source: AsyncIterable<RetryInfo | RetryInfo[]> | Iterable<RetryInfo | RetryInfo[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [RetryInfo.encode(p).finish()];
        }
      } else {
        yield* [RetryInfo.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, RetryInfo>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<RetryInfo> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [RetryInfo.decode(p)];
        }
      } else {
        yield* [RetryInfo.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): RetryInfo {
    return { retry_delay: isSet(object.retry_delay) ? Duration.fromJSON(object.retry_delay) : null };
  },

  toJSON(message: RetryInfo): unknown {
    const obj: any = {};
    if (message.retry_delay !== undefined && message.retry_delay !== null) {
      obj.retry_delay = Duration.toJSON(message.retry_delay);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RetryInfo>, I>>(base?: I): RetryInfo {
    return RetryInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RetryInfo>, I>>(object: I): RetryInfo {
    const message = createBaseRetryInfo();
    message.retry_delay = (object.retry_delay !== undefined && object.retry_delay !== null)
      ? Duration.fromPartial(object.retry_delay)
      : null;
    return message;
  },
};

function createBaseDebugInfo(): DebugInfo {
  return { stack_entries: [], detail: "" };
}

export const DebugInfo = {
  encode(message: DebugInfo, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.stack_entries) {
      writer.uint32(10).string(v!);
    }
    if (message.detail !== "") {
      writer.uint32(18).string(message.detail);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DebugInfo {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDebugInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.stack_entries.push(reader.string());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.detail = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<DebugInfo, Uint8Array>
  async *encodeTransform(
    source: AsyncIterable<DebugInfo | DebugInfo[]> | Iterable<DebugInfo | DebugInfo[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [DebugInfo.encode(p).finish()];
        }
      } else {
        yield* [DebugInfo.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, DebugInfo>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<DebugInfo> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [DebugInfo.decode(p)];
        }
      } else {
        yield* [DebugInfo.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): DebugInfo {
    return {
      stack_entries: globalThis.Array.isArray(object?.stack_entries)
        ? object.stack_entries.map((e: any) => globalThis.String(e))
        : [],
      detail: isSet(object.detail) ? globalThis.String(object.detail) : "",
    };
  },

  toJSON(message: DebugInfo): unknown {
    const obj: any = {};
    if (message.stack_entries?.length) {
      obj.stack_entries = message.stack_entries;
    }
    if (message.detail !== "") {
      obj.detail = message.detail;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DebugInfo>, I>>(base?: I): DebugInfo {
    return DebugInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DebugInfo>, I>>(object: I): DebugInfo {
    const message = createBaseDebugInfo();
    message.stack_entries = object.stack_entries?.map((e) => e) || [];
    message.detail = object.detail ?? "";
    return message;
  },
};

function createBaseQuotaFailure(): QuotaFailure {
  return { violations: [] };
}

export const QuotaFailure = {
  encode(message: QuotaFailure, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.violations) {
      QuotaFailure_Violation.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QuotaFailure {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQuotaFailure();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.violations.push(QuotaFailure_Violation.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<QuotaFailure, Uint8Array>
  async *encodeTransform(
    source: AsyncIterable<QuotaFailure | QuotaFailure[]> | Iterable<QuotaFailure | QuotaFailure[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [QuotaFailure.encode(p).finish()];
        }
      } else {
        yield* [QuotaFailure.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, QuotaFailure>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<QuotaFailure> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [QuotaFailure.decode(p)];
        }
      } else {
        yield* [QuotaFailure.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): QuotaFailure {
    return {
      violations: globalThis.Array.isArray(object?.violations)
        ? object.violations.map((e: any) => QuotaFailure_Violation.fromJSON(e))
        : [],
    };
  },

  toJSON(message: QuotaFailure): unknown {
    const obj: any = {};
    if (message.violations?.length) {
      obj.violations = message.violations.map((e) => QuotaFailure_Violation.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QuotaFailure>, I>>(base?: I): QuotaFailure {
    return QuotaFailure.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QuotaFailure>, I>>(object: I): QuotaFailure {
    const message = createBaseQuotaFailure();
    message.violations = object.violations?.map((e) => QuotaFailure_Violation.fromPartial(e)) || [];
    return message;
  },
};

function createBaseQuotaFailure_Violation(): QuotaFailure_Violation {
  return { subject: "", description: "" };
}

export const QuotaFailure_Violation = {
  encode(message: QuotaFailure_Violation, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.subject !== "") {
      writer.uint32(10).string(message.subject);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QuotaFailure_Violation {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQuotaFailure_Violation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.subject = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<QuotaFailure_Violation, Uint8Array>
  async *encodeTransform(
    source:
      | AsyncIterable<QuotaFailure_Violation | QuotaFailure_Violation[]>
      | Iterable<QuotaFailure_Violation | QuotaFailure_Violation[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [QuotaFailure_Violation.encode(p).finish()];
        }
      } else {
        yield* [QuotaFailure_Violation.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, QuotaFailure_Violation>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<QuotaFailure_Violation> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [QuotaFailure_Violation.decode(p)];
        }
      } else {
        yield* [QuotaFailure_Violation.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): QuotaFailure_Violation {
    return {
      subject: isSet(object.subject) ? globalThis.String(object.subject) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
    };
  },

  toJSON(message: QuotaFailure_Violation): unknown {
    const obj: any = {};
    if (message.subject !== "") {
      obj.subject = message.subject;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QuotaFailure_Violation>, I>>(base?: I): QuotaFailure_Violation {
    return QuotaFailure_Violation.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QuotaFailure_Violation>, I>>(object: I): QuotaFailure_Violation {
    const message = createBaseQuotaFailure_Violation();
    message.subject = object.subject ?? "";
    message.description = object.description ?? "";
    return message;
  },
};

function createBasePreconditionFailure(): PreconditionFailure {
  return { violations: [] };
}

export const PreconditionFailure = {
  encode(message: PreconditionFailure, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.violations) {
      PreconditionFailure_Violation.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PreconditionFailure {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePreconditionFailure();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.violations.push(PreconditionFailure_Violation.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<PreconditionFailure, Uint8Array>
  async *encodeTransform(
    source:
      | AsyncIterable<PreconditionFailure | PreconditionFailure[]>
      | Iterable<PreconditionFailure | PreconditionFailure[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [PreconditionFailure.encode(p).finish()];
        }
      } else {
        yield* [PreconditionFailure.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, PreconditionFailure>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<PreconditionFailure> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [PreconditionFailure.decode(p)];
        }
      } else {
        yield* [PreconditionFailure.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): PreconditionFailure {
    return {
      violations: globalThis.Array.isArray(object?.violations)
        ? object.violations.map((e: any) => PreconditionFailure_Violation.fromJSON(e))
        : [],
    };
  },

  toJSON(message: PreconditionFailure): unknown {
    const obj: any = {};
    if (message.violations?.length) {
      obj.violations = message.violations.map((e) => PreconditionFailure_Violation.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PreconditionFailure>, I>>(base?: I): PreconditionFailure {
    return PreconditionFailure.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PreconditionFailure>, I>>(object: I): PreconditionFailure {
    const message = createBasePreconditionFailure();
    message.violations = object.violations?.map((e) => PreconditionFailure_Violation.fromPartial(e)) || [];
    return message;
  },
};

function createBasePreconditionFailure_Violation(): PreconditionFailure_Violation {
  return { type: "", subject: "", description: "" };
}

export const PreconditionFailure_Violation = {
  encode(message: PreconditionFailure_Violation, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.type !== "") {
      writer.uint32(10).string(message.type);
    }
    if (message.subject !== "") {
      writer.uint32(18).string(message.subject);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PreconditionFailure_Violation {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePreconditionFailure_Violation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.type = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.subject = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<PreconditionFailure_Violation, Uint8Array>
  async *encodeTransform(
    source:
      | AsyncIterable<PreconditionFailure_Violation | PreconditionFailure_Violation[]>
      | Iterable<PreconditionFailure_Violation | PreconditionFailure_Violation[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [PreconditionFailure_Violation.encode(p).finish()];
        }
      } else {
        yield* [PreconditionFailure_Violation.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, PreconditionFailure_Violation>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<PreconditionFailure_Violation> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [PreconditionFailure_Violation.decode(p)];
        }
      } else {
        yield* [PreconditionFailure_Violation.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): PreconditionFailure_Violation {
    return {
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      subject: isSet(object.subject) ? globalThis.String(object.subject) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
    };
  },

  toJSON(message: PreconditionFailure_Violation): unknown {
    const obj: any = {};
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.subject !== "") {
      obj.subject = message.subject;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PreconditionFailure_Violation>, I>>(base?: I): PreconditionFailure_Violation {
    return PreconditionFailure_Violation.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PreconditionFailure_Violation>, I>>(
    object: I,
  ): PreconditionFailure_Violation {
    const message = createBasePreconditionFailure_Violation();
    message.type = object.type ?? "";
    message.subject = object.subject ?? "";
    message.description = object.description ?? "";
    return message;
  },
};

function createBaseBadRequest(): BadRequest {
  return { field_violations: [] };
}

export const BadRequest = {
  encode(message: BadRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.field_violations) {
      BadRequest_FieldViolation.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BadRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBadRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.field_violations.push(BadRequest_FieldViolation.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<BadRequest, Uint8Array>
  async *encodeTransform(
    source: AsyncIterable<BadRequest | BadRequest[]> | Iterable<BadRequest | BadRequest[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [BadRequest.encode(p).finish()];
        }
      } else {
        yield* [BadRequest.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, BadRequest>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<BadRequest> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [BadRequest.decode(p)];
        }
      } else {
        yield* [BadRequest.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): BadRequest {
    return {
      field_violations: globalThis.Array.isArray(object?.field_violations)
        ? object.field_violations.map((e: any) => BadRequest_FieldViolation.fromJSON(e))
        : [],
    };
  },

  toJSON(message: BadRequest): unknown {
    const obj: any = {};
    if (message.field_violations?.length) {
      obj.field_violations = message.field_violations.map((e) => BadRequest_FieldViolation.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BadRequest>, I>>(base?: I): BadRequest {
    return BadRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BadRequest>, I>>(object: I): BadRequest {
    const message = createBaseBadRequest();
    message.field_violations = object.field_violations?.map((e) => BadRequest_FieldViolation.fromPartial(e)) || [];
    return message;
  },
};

function createBaseBadRequest_FieldViolation(): BadRequest_FieldViolation {
  return { field: "", description: "" };
}

export const BadRequest_FieldViolation = {
  encode(message: BadRequest_FieldViolation, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.field !== "") {
      writer.uint32(10).string(message.field);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BadRequest_FieldViolation {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBadRequest_FieldViolation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.field = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<BadRequest_FieldViolation, Uint8Array>
  async *encodeTransform(
    source:
      | AsyncIterable<BadRequest_FieldViolation | BadRequest_FieldViolation[]>
      | Iterable<BadRequest_FieldViolation | BadRequest_FieldViolation[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [BadRequest_FieldViolation.encode(p).finish()];
        }
      } else {
        yield* [BadRequest_FieldViolation.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, BadRequest_FieldViolation>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<BadRequest_FieldViolation> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [BadRequest_FieldViolation.decode(p)];
        }
      } else {
        yield* [BadRequest_FieldViolation.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): BadRequest_FieldViolation {
    return {
      field: isSet(object.field) ? globalThis.String(object.field) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
    };
  },

  toJSON(message: BadRequest_FieldViolation): unknown {
    const obj: any = {};
    if (message.field !== "") {
      obj.field = message.field;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BadRequest_FieldViolation>, I>>(base?: I): BadRequest_FieldViolation {
    return BadRequest_FieldViolation.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BadRequest_FieldViolation>, I>>(object: I): BadRequest_FieldViolation {
    const message = createBaseBadRequest_FieldViolation();
    message.field = object.field ?? "";
    message.description = object.description ?? "";
    return message;
  },
};

function createBaseRequestInfo(): RequestInfo {
  return { request_id: "", serving_data: "" };
}

export const RequestInfo = {
  encode(message: RequestInfo, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.request_id !== "") {
      writer.uint32(10).string(message.request_id);
    }
    if (message.serving_data !== "") {
      writer.uint32(18).string(message.serving_data);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RequestInfo {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRequestInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.request_id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.serving_data = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<RequestInfo, Uint8Array>
  async *encodeTransform(
    source: AsyncIterable<RequestInfo | RequestInfo[]> | Iterable<RequestInfo | RequestInfo[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [RequestInfo.encode(p).finish()];
        }
      } else {
        yield* [RequestInfo.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, RequestInfo>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<RequestInfo> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [RequestInfo.decode(p)];
        }
      } else {
        yield* [RequestInfo.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): RequestInfo {
    return {
      request_id: isSet(object.request_id) ? globalThis.String(object.request_id) : "",
      serving_data: isSet(object.serving_data) ? globalThis.String(object.serving_data) : "",
    };
  },

  toJSON(message: RequestInfo): unknown {
    const obj: any = {};
    if (message.request_id !== "") {
      obj.request_id = message.request_id;
    }
    if (message.serving_data !== "") {
      obj.serving_data = message.serving_data;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RequestInfo>, I>>(base?: I): RequestInfo {
    return RequestInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RequestInfo>, I>>(object: I): RequestInfo {
    const message = createBaseRequestInfo();
    message.request_id = object.request_id ?? "";
    message.serving_data = object.serving_data ?? "";
    return message;
  },
};

function createBaseResourceInfo(): ResourceInfo {
  return { resource_type: "", resource_name: "", owner: "", description: "" };
}

export const ResourceInfo = {
  encode(message: ResourceInfo, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.resource_type !== "") {
      writer.uint32(10).string(message.resource_type);
    }
    if (message.resource_name !== "") {
      writer.uint32(18).string(message.resource_name);
    }
    if (message.owner !== "") {
      writer.uint32(26).string(message.owner);
    }
    if (message.description !== "") {
      writer.uint32(34).string(message.description);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ResourceInfo {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResourceInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.resource_type = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.resource_name = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.owner = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.description = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<ResourceInfo, Uint8Array>
  async *encodeTransform(
    source: AsyncIterable<ResourceInfo | ResourceInfo[]> | Iterable<ResourceInfo | ResourceInfo[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [ResourceInfo.encode(p).finish()];
        }
      } else {
        yield* [ResourceInfo.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, ResourceInfo>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<ResourceInfo> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [ResourceInfo.decode(p)];
        }
      } else {
        yield* [ResourceInfo.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): ResourceInfo {
    return {
      resource_type: isSet(object.resource_type) ? globalThis.String(object.resource_type) : "",
      resource_name: isSet(object.resource_name) ? globalThis.String(object.resource_name) : "",
      owner: isSet(object.owner) ? globalThis.String(object.owner) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
    };
  },

  toJSON(message: ResourceInfo): unknown {
    const obj: any = {};
    if (message.resource_type !== "") {
      obj.resource_type = message.resource_type;
    }
    if (message.resource_name !== "") {
      obj.resource_name = message.resource_name;
    }
    if (message.owner !== "") {
      obj.owner = message.owner;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ResourceInfo>, I>>(base?: I): ResourceInfo {
    return ResourceInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ResourceInfo>, I>>(object: I): ResourceInfo {
    const message = createBaseResourceInfo();
    message.resource_type = object.resource_type ?? "";
    message.resource_name = object.resource_name ?? "";
    message.owner = object.owner ?? "";
    message.description = object.description ?? "";
    return message;
  },
};

function createBaseHelp(): Help {
  return { links: [] };
}

export const Help = {
  encode(message: Help, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.links) {
      Help_Link.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Help {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHelp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.links.push(Help_Link.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<Help, Uint8Array>
  async *encodeTransform(source: AsyncIterable<Help | Help[]> | Iterable<Help | Help[]>): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [Help.encode(p).finish()];
        }
      } else {
        yield* [Help.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, Help>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<Help> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [Help.decode(p)];
        }
      } else {
        yield* [Help.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): Help {
    return {
      links: globalThis.Array.isArray(object?.links) ? object.links.map((e: any) => Help_Link.fromJSON(e)) : [],
    };
  },

  toJSON(message: Help): unknown {
    const obj: any = {};
    if (message.links?.length) {
      obj.links = message.links.map((e) => Help_Link.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Help>, I>>(base?: I): Help {
    return Help.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Help>, I>>(object: I): Help {
    const message = createBaseHelp();
    message.links = object.links?.map((e) => Help_Link.fromPartial(e)) || [];
    return message;
  },
};

function createBaseHelp_Link(): Help_Link {
  return { description: "", url: "" };
}

export const Help_Link = {
  encode(message: Help_Link, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.description !== "") {
      writer.uint32(10).string(message.description);
    }
    if (message.url !== "") {
      writer.uint32(18).string(message.url);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Help_Link {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHelp_Link();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.description = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.url = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<Help_Link, Uint8Array>
  async *encodeTransform(
    source: AsyncIterable<Help_Link | Help_Link[]> | Iterable<Help_Link | Help_Link[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [Help_Link.encode(p).finish()];
        }
      } else {
        yield* [Help_Link.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, Help_Link>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<Help_Link> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [Help_Link.decode(p)];
        }
      } else {
        yield* [Help_Link.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): Help_Link {
    return {
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      url: isSet(object.url) ? globalThis.String(object.url) : "",
    };
  },

  toJSON(message: Help_Link): unknown {
    const obj: any = {};
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.url !== "") {
      obj.url = message.url;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Help_Link>, I>>(base?: I): Help_Link {
    return Help_Link.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Help_Link>, I>>(object: I): Help_Link {
    const message = createBaseHelp_Link();
    message.description = object.description ?? "";
    message.url = object.url ?? "";
    return message;
  },
};

function createBaseLocalizedMessage(): LocalizedMessage {
  return { locale: "", message: "" };
}

export const LocalizedMessage = {
  encode(message: LocalizedMessage, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.locale !== "") {
      writer.uint32(10).string(message.locale);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): LocalizedMessage {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLocalizedMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.locale = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<LocalizedMessage, Uint8Array>
  async *encodeTransform(
    source: AsyncIterable<LocalizedMessage | LocalizedMessage[]> | Iterable<LocalizedMessage | LocalizedMessage[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [LocalizedMessage.encode(p).finish()];
        }
      } else {
        yield* [LocalizedMessage.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, LocalizedMessage>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<LocalizedMessage> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [LocalizedMessage.decode(p)];
        }
      } else {
        yield* [LocalizedMessage.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): LocalizedMessage {
    return {
      locale: isSet(object.locale) ? globalThis.String(object.locale) : "",
      message: isSet(object.message) ? globalThis.String(object.message) : "",
    };
  },

  toJSON(message: LocalizedMessage): unknown {
    const obj: any = {};
    if (message.locale !== "") {
      obj.locale = message.locale;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LocalizedMessage>, I>>(base?: I): LocalizedMessage {
    return LocalizedMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LocalizedMessage>, I>>(object: I): LocalizedMessage {
    const message = createBaseLocalizedMessage();
    message.locale = object.locale ?? "";
    message.message = object.message ?? "";
    return message;
  },
};

export interface DataLoaderOptions {
  cache?: boolean;
}

export interface DataLoaders {
  rpcDataLoaderOptions?: DataLoaderOptions;
  getDataLoader<T>(identifier: string, constructorFn: () => T): T;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | bigint | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
